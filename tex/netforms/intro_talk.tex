% intro talk in german
%\documentclass[NET,a4paper,12pt,ngerman]{netforms}

% intro talk in english
\documentclass[NET,a4paper,12pt,english]{netforms}

\usepackage[utf8]{inputenc}
\usepackage{tumlang}
\usepackage{tumcontact}
\usepackage{scrlayer-scrpage}
\usepackage[textsize=scriptsize]{todonotes}
% Disable todonotes with
%\setuptodonotes{disable}
\setuptodonotes{inline}
\usepackage{pgfgantt}
\usepackage{float}
\usepackage{enumitem}
\newlist{researchquestions}{enumerate}{1}
\setlist[researchquestions,1]{label=\textbf{\textit{RQ \arabic*}}, resume}


\geometry{%
	top=20mm,
	bottom=20mm,
	left=25mm,
	right=25mm,
	headsep=1.5cm,
	includehead,
}
\input{studentdefs}

\pagestyle{scrheadings}
\clearscrheadfoot
\chead{\TUMheader{1cm}}

\renewcommand{\maketitle}{%
	\begin{center}
		\textbf{\introductoryheadline}%

		\Large%
		\textbf{\thetitle}%
	\end{center}

	\footnotesize%
	\hrule
	\vskip1ex
	\begin{tabular}{ll}
		\thenamelabel: & \thevorname{} \textbf{\thenachname}\\
		\theadvisorlabel: & \hspace*{-.5ex}\thebetreuer\\
		\thesupervisorlabel: & \chairhead\\
		\thebeginlabel: & \thebeginnmonat/\thebeginnjahr\\
		\theendlabel: & \theendmonat/\theendjahr\\
	\end{tabular}
	\vskip1ex
	\hrule
	\vskip4ex
}

\linespread{1.2}
\setlength{\parskip}{.5\baselineskip}

\begin{document}
\maketitle

\subsection*{Topic}

Blockchains are slow, expensive, and cannot scale to internet-scale applications. 
In recent years, several "Layer 2" protocols have been built on top of existing 
blockchain protocols to improve scalability and efficiency. However, these 
solutions are centralized and suffer from worse latency (time to 
finality)~\cite{arbitrum-sequencer-trustmodel, blockworks-sequencer-centralization}. 
This situation calls for a new design. 

Recent works such as Fastpay~\cite{fastpay}, ABC~\cite{abc}, and pod~\cite{pod} 
relax the consensus requirements, to allow for peer-to-peer payments in just 1–2 network 
without validator-to-validator communication. These systems are not generalised, 
unlike modern blockchains, which allow for deploying arbitrary Turing-complete programs 
(smart contracts). Smart contracts are essential to build and compose 
applications, without the need of deploying a new network.

To enable smart contract functionality, blockchain systems rely on consensus 
protocols to globally order transactions. A node observing the network 
can apply a deterministic state machine to the ordered sequence of 
transactions to arrive at the same state—this is known as state machine 
replication (SMR)~\cite{smr, vitalik, wood}. However, the above asynchronous protocols do not 
provide this global ordering and thus cannot be easily extended to 
support smart contracts.

In this work, we propose leveraging conflict-free replicated 
data types~\cite{crdt} (CRDTs) to build smart contract functionality for 
asynchronous networks. The key insight is that operations on 
CRDTs are commutative, allowing nodes to maintain a 
consistent state without requiring global ordering of transactions.

Concretely, we propose modifications to the Ethereum 
Virtual Machine (EVM)~\cite{vitalik, wood}—the most widely 
used smart contract VM—to enable composing these CRDT-like 
primitives together. 
Finally, we analyze these primitives and their composition in 
the VM environment to prove their safety and liveness.
\subsection*{Related Work}

Several efforts have been made
to build protocols on top of existing blockchains to 
improve efficiency and scalability, known as ``Layer 2" 
solutions~\cite{optimism, zksync, polygon, arbitrum, arbitrum-paper}. 
The prominent solution today depend on a special party called 
a sequencer, which can censor or reorder transactions temporarily. Users must 
still wait for their transactions to be posted on the blockchain for 
security guarantees, resulting in similar or worse latency. 
Additionally, the network's throughput is limited by the number of 
transactions that can be processed by the sequencer sequentially.

Guerraoui et al.~\cite{consensus-number} demonstrated that 
decentralized payments are possible without global ordering. This insight 
led to several works in the literature, including FastPay~\cite{fastpay}, 
ABC~\cite{abc}, and pod~\cite{pod}, which relax the consensus requirement. 
These systems allow transactions to finalize in just 1–2 network 
round-trips without requiring validator-to-validator communication. 
Furthermore, they enable horizontal scalability—nodes can add more 
machines to increase the network's throughput.

All of these systems were designed specifically for payments.
Sui Lutris~\cite{sui-lutris} allowed for writing arbitrary smart 
contracts where the state can only be modified by a single party. 
However, this design has three key limitations: (1) single-owned states 
are not expressive enough for building common blockchain applications 
like balance-based tokens, (2) the system requires adopting new Move 
language semantics, and (3) it lacks support for essential context data 
like current timestamp in the fast path— necessary for applications 
such as auctions and voting systems.

\subsection*{Research Questions}
\textbf{What data structures and operations are safe in the fast path?} 

Sui Lutris \cite{sui-lutris} only allows for single-owned states, which severely 
hinders the applications possible in the fast path. Consider the simple example 
of an ERC20 token: the balance cannot be a single-owned value since multiple 
parties can simultaneously send money to a recipient, incrementing their balance. 
While concurrent increments are safe in the fast path, as shown by 
Fastpay \cite{fastpay} and other fast payment constructions, they cannot 
be implemented using just single-owned states.

Stingray~\cite{stingray} addresses this by introducing a bounded counter 
data structure where additions are commutative and can be performed 
by anyone, while subtractions are restricted to the counter's owner. 
This enables balance-based tokens in the fast path. 

Counters are a very simple example of CRDTs~\cite{crdt}, 
where the order of increment 
operations does not matter. There exist several other CRDTs
and they are a well-studied class of
primitives in the distributed computing literature.
We would like to find how these primitives 
can be safely used in the fast path, allowing for more 
expressive smart contracts.

\textbf{Can EVM be modified to support async execution?} 

A key limitation of Sui Lutris is its requirement for smart contract 
developers to learn a new programming paradigm and semantics, which 
hinders the adoption of async networks. We would like to explore if 
EVM—the most widely adopted and mature 
smart contract environment—to enable async execution. The EVM is 
a stack-based deterministic state machine that assumes all nodes 
execute the VM on (i) the same transaction ledger and 
(ii) with identical context variables, resulting in consistent 
state updates after each transaction. To safely use the EVM in an 
async execution environment, both requirements must be relaxed. 
State reads and writes should exclusively use the fast path primitives 
described above, ensuring that honest validators maintain consistent states 
regardless of transaction execution order. Additionally, the 
usage of context variables, such as timestamps, 
must be modified to ensure safety in the fast path.


\textbf{Is the composition of these primitives safe?} 

We will start by analyzing the individual primitives independently and 
formally proving their safety and liveness in the async environment. 
We then aim to propose a model that demonstrates the secure composition 
of these primitives with the VM. This analysis is crucial for 
showing that primitives can be safely composed with each other 
to build arbitrary contracts. 

There are many parallels between an asynchronous fast execution 
environment and traditional database management systems (DBMS). 
Both allow state read/write operations while ensuring certain 
invariants. Since no previous works in the blockchain literature 
formally examine the composition of such CRDT primitives, we plan 
to draw inspiration from traditional DBMS literature for our modeling framework.

\subsection*{Approach}
\paragraph{Literature Review} We will conduct a comprehensive review of state-of-the-art asynchronous protocols to understand their differences, limitations, models, and proving techniques. We will also examine traditional DBMS systems for insights into VM and primitive composition modeling.

\paragraph{Core construction} We will introduce CRDT-like primitives—Sets, Counters, Owned States, and Bounded Counters—and implement modifications to the EVM to expose these primitives to the smart contract environment. We will also design an interface for safe timestamp exposure in the execution environment. that expose these primitives to the smart contract environment.

\paragraph{Analysis} We will develop a model to analyze this construction and prove that these primitives can be safely instantiated independently and composed within the new VM.

\paragraph{Prototype and Applications}
We will build a prototype of the modified VM with an async network and conduct basic benchmarks. To demonstrate the value of these modified VMs, we will implement contracts for common blockchain applications: fungible and non-fungible tokens, registries, auctions, and voting systems.

\subsection*{Planned Schedule}
\begin{figure}[H]
  \centering
  \begin{ganttchart}[
      x unit=0.8mm,
      y unit title=0.6cm,
      title height=1,
      title label font=\small,
      bar label font=\scriptsize,
      milestone label font=\scriptsize,
      milestone inline label node/.append style={left=2mm},
      milestone/.append style={fill=orange, shape=rectangle},
      y unit chart=.6cm,
      time slot format=isodate,
      time slot unit=day,
      inline,
      bar height=0.7,
    ]{2025-07-01}{2025-12-30}
    \gantttitlecalendar{month=name}\\
    \ganttbar{Literature Review}{2025-07-01}{2025-08-15}\\
    \ganttbar{Core Construction}{2025-07-30}{2025-09-15}\\
    \ganttbar{Analysis}{2025-09-15}{2025-11-15}\\
    \ganttbar{Prototype}{2025-11-15}{2025-12-23}\\
    \ganttmilestone{Intermediate talk}{2025-10-15}\\
    \ganttmilestone{Submission}{2025-12-24}
  \end{ganttchart}
  \label{fig:work-plan}
\end{figure}

\bibliographystyle{IEEEtran}
\scriptsize
\bibliography{IEEEabrv,lit}

\end{document}
