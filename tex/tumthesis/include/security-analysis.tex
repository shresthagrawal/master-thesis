\chapter{Security Analysis}
\label{chap:security-analysis}

In this chapter, we prove that our protocol satisfies the security properties defined in Section~\ref{sec:security-properties}: conservation of value (S1), authenticity (S2), and liveness. We begin with safety, which we formalize as a \emph{per-account common prefix} property -- honest validators never disagree on the chain of finalized actions for any account. We first prove this for the base FastPay protocol and then show that recovery preserves it, using the $5f+1$ fault model to rule out conflicting certificates. From common prefix we derive conservation of value and authenticity. We then turn to liveness, showing that non-conflicting transactions finalize within a single round trip, that stuck nonces always resolve via Simplex-style $\bot$-voting, and that healing clients can construct recovery transactions to unlock progress.

\section{Per-Account Finalized Chain}

Fix an account $a$. Each validator $v_i$ maintains two counters: $\mathsf{finalised}[a]$ (the last finalized nonce) and $\mathsf{nonce}[a]$ (the next nonce it is willing to vote on). We define the \emph{per-account finalized chain} at validator $v_i$ as:
\[
L_i^a = (\ell_i^a(1), \ell_i^a(2), \ldots, \ell_i^a(\mathsf{finalised}_i[a])),
\]
where each entry $\ell_i^a(k)$ is either a transaction $tx_k$ (payment or recovery) with $(tx_k.\mathsf{sender} = a, tx_k.\mathsf{nonce} = k)$, or the symbol $\bot$ (nonce $k$ is skipped).

\begin{definition}[Per-account common prefix]
For any account $a$ and any two honest validators $v_i, v_j$, their chains $L_i^a$ and $L_j^a$ are prefix comparable. Equivalently, for all $k \leq \min(\mathsf{finalised}_i[a], \mathsf{finalised}_j[a])$: $\ell_i^a(k) = \ell_j^a(k)$.
\end{definition}

This implies standard confirmation safety: if a recipient observes a valid finality certificate for a payment $tx$ from $a$ at nonce $k$, then every honest validator's chain that reaches nonce $k$ contains $tx$ at position $k$.

\section{FastPay Without Recovery}

In the optimistic protocol, validators enforce local sequencing using the nonce check and pending flag. An honest validator votes for at most one payment transaction per $(a, k)$.

\begin{lemma}[Uniqueness at a nonce]
\label{lem:uniqueness}
For fixed $(a, k)$, there cannot exist two distinct non-$\bot$ transactions $tx \neq tx'$ such that both obtain finality quorums of size $n - f$.
\end{lemma}

\begin{proof}
Any two sets of size $n - f$ intersect in at least $(n-f) + (n-f) - n = n - 2f \geq f + 1$ validators (for $n \geq 3f + 1$). At least one is honest and cannot vote for two different non-$\bot$ transactions at the same $(a, k)$.
\end{proof}

\section{Recovery Preserves Common Prefix}

Recovery introduces skipping nonces ($\bot$ entries) and finalizing recovery transactions that execute earlier payments. We must show: (A) recovery transactions do not fork at their own nonce, and (B) recovery cannot revert previously confirmed payments.

\textbf{(A) No fork at recovery nonce.} A recovery transaction is subject to the same pending and nonce checks as payments. By Lemma~\ref{lem:uniqueness}, two distinct non-$\bot$ transactions (payment or recovery) cannot both obtain finality quorums at the same $(a, k)$.

\textbf{(B) Recovery cannot change finalized entries.} The $5f+1$ model ensures that if any transaction was finalized, a conflicting tip cannot be justified.

\begin{lemma}[Finalized transactions block conflicting tips]
\label{lem:no-conflicting-tip}
Assume $n \geq 5f + 1$. If a transaction $tx$ at $(a, k)$ has a finality quorum of size $n - f$, then no conflicting transaction $tx' \neq tx$ at $(a, k)$ can obtain an $(n - 3f)$-certificate.
\end{lemma}

\begin{proof}
Let $F$ be the $n - f$ validators who voted for $tx$. Suppose $tx'$ has a notarization set $N$ of size $n - 3f$. Then $|F \cap N| \geq (n-f) + (n-3f) - n = n - 4f \geq f + 1$ (since $n \geq 5f + 1$). Thus $F \cap N$ contains at least one honest validator who cannot vote for two different transactions at $(a, k)$.
\end{proof}

Since \textsc{ValidateRecovery} requires an $(n-3f)$-certificate for the tip, a recovery transaction cannot point to a conflicting transaction if the original was finalized.

\begin{lemma}[Skipping is safe]
\label{lem:skip-safe}
Assume $n \geq 5f + 1$. If an $(n - 3f)$-certificate for $\bot$ exists at $(a, k)$, then no transaction at nonce $k$ can be finalized.
\end{lemma}

\begin{proof}
Honest validators sign $\bot$ only after observing an $(n-f)$-certificate with no value reaching $n - 3f$ support. In the $5f+1$ model, if any transaction had an $(n-f)$-finality quorum, any $(n-f)$-certificate must contain at least $n - 3f$ votes for that transaction. Hence observing no $n - 3f$ support implies no finality occurred.
\end{proof}

\begin{theorem}[Per-account common prefix safety]
\label{thm:safety}
Assume $n \geq 5f + 1$. For any account $a$, the protocol maintains per-account common prefix: for any two honest validators $v_i, v_j$, their chains $L_i^a$ and $L_j^a$ are prefix comparable.
\end{theorem}

\begin{proof}
Consider the first nonce $k$ where two honest validators disagree. Disagreement at $k$ can only arise in three ways:
\begin{enumerate}
    \item Two different non-$\bot$ transactions both finalized via the fast path: impossible by Lemma~\ref{lem:uniqueness}.
    \item One validator has $\bot$ and another has a non-$\bot$ transaction (via recovery): impossible by Lemma~\ref{lem:skip-safe}, since a $\bot$ certificate implies no transaction was finalized.
    \item Two different non-$\bot$ transactions finalized via recovery with different tips: impossible by Lemma~\ref{lem:no-conflicting-tip}, since conflicting tips cannot both have $(n-3f)$-certificates.
\end{enumerate}
No such disagreement nonce $k$ exists.
\end{proof}

We now connect the per-account common prefix to the payment properties stated in
Section~\ref{sec:security-properties}.

\begin{lemma}[Conservation of value (S1)]
\label{lem:s1-conservation}
Assume $n \ge 5f+1$ and that all honest validators start from the same initial balances.
Let $\mathsf{bal}_i$ denote the balance mapping maintained by an honest validator $v_i$ at any time.
Then the total value is invariant:
\[
\sum_{a} \mathsf{bal}_i(a) \;=\; \sum_{a} \mathsf{bal}_i^{(0)}(a),
\]
i.e., the protocol does not create or destroy money; it only transfers value between accounts.
\end{lemma}

\begin{proof}
By Theorem~\ref{thm:safety}, for each sender account $a$ there is a single well-defined finalized chain
(common prefix) that honest validators extend, so honest validators never diverge on which
(non-$\bot$) payments are finalized for any sender nonce.

It remains to observe that every state transition that changes balances is value-preserving.
Inspect Algorithm~\ref{alg:validator-recovery-cert}: the only operation that updates balances is \textsc{ExecuteTransfer},
called at line~\ref{line:execute-transfer}, which subtracts $\mathsf{amt}$ from the sender (line~\ref{line:balance-sub})
and adds the same $\mathsf{amt}$ to the recipient (line~\ref{line:balance-add}). Thus each executed payment preserves the sum of all balances.
Skipping a nonce using $\bot$ does not update balances, and recovery transactions have amount
zero and only serve to select and/or execute an underlying payment via $\textsc{GetTxChainStart}$.
Therefore, by induction over the sequence of executed transfers at $v_i$, the global sum of balances
at $v_i$ is invariant and equals its initial value.
Since all honest validators start from the same initial balances, the total money supply is fixed
system-wide.
\end{proof}

\begin{lemma}[Authenticity / authorized spending (S2)]
\label{lem:s2-authenticity}
If an honest validator executes a payment transaction $\mathsf{tx}$ that debits sender $s$,
then $\mathsf{tx}$ is authorized by $s$ (i.e., it carries a valid signature under $s$'s public key),
except with negligible probability.
\end{lemma}

\begin{proof}
A payment is executed only via Algorithm~\ref{alg:validator-recovery-cert} when finality is reached
(line~\ref{line:check-finality}) and the executed
transaction is the start of the referenced chain $\mathsf{tx}_{\mathit{orig}}=\textsc{GetTxChainStart}(\cdot)$
(line~\ref{line:get-chain-start}),
which is either a direct payment or a payment referenced by a recovery transaction.
In either case, the payment must have accumulated votes from validators before it can be executed
(either directly by finality, or indirectly because recovery validation requires certificates about the
referenced tip and intermediate nonces in Algorithm~\ref{alg:validator-recovery-tx}).

Honest validators vote only after verifying the sender signature on the transaction
(Algorithm~\ref{alg:validator-recovery-tx}, line~\ref{line:verify-sig}). Any quorum certificate contains at least one honest validator signature,
hence the executed payment must have passed signature verification at an honest validator.
Under EUF-CMA security, this implies the payment was authorized by the sender, except with
negligible probability.
\end{proof}

\section{Liveness}

We prove the payment liveness property stated in Section~\ref{sec:security-properties}:
after GST, any client that is (i) honest, or (ii) healing and has healed (i.e., it eventually
stops equivocating), can always transfer funds. Concretely, such a client can obtain a
finality certificate for valid payments, possibly after first issuing a recovery transaction
if its account is locked. Permanently Byzantine clients that keep equivocating forever are
not guaranteed to make progress.

The proof decomposes into: (1) fast-path progress for non-conflicting transactions, and
(2) recovery progress that restores the ability to make non-conflicting progress after
equivocation.

\begin{lemma}[Fast-path liveness for non-conflicting transactions]
\label{lem:fast-path-liveness}
After GST (partial synchrony), if a client submits a single non-conflicting transaction $tx$ for
the current nonce, then the client obtains $n - f$ votes within one network round trip (up to
message delay $\delta$), and the transaction can be finalized.
\end{lemma}

\begin{proof}
At least $n - f$ validators are honest and will accept and vote for $tx$
(Algorithm~\ref{alg:validator-recovery-tx}). Votes are disseminated to the client (and propagated
among validators), so the client collects $n - f$ votes within one round trip in the synchronous
period. This matches the standard FastPay ``client collects a quorum of signatures'' pattern.
\end{proof}

\textbf{No permanent deadlock.} Next, we show that even when equivocation occurs, the protocol does not get permanently stuck. Either some transaction has at least notarization quorum ($n - 3f$ votes), or validators will sign $\bot$, leading to at least $n - 3f$ votes on $\bot$ to indicate the nonce can be safely skipped.

\begin{lemma}[A notarized value always forms for a stuck nonce]
\label{lem:notarized-forms}
Assume $n \geq 5f + 1$. For any nonce $k$, if no transaction reaches finality at $k$, then
eventually an $n - 3f$ notarization certificate forms for either (i) some transaction $tx$ with
majority support, or (ii) $\bot$.
\end{lemma}

\begin{proof}
This is the Simplex-style ``prevent getting stuck'' argument: when parties observe $n - f$ votes
without any $n - 3f$ certificate, they can safely vote for $\bot$, which guarantees that a
certificate (possibly for $\bot$) eventually forms.

Our protocol implements this mechanism in Algorithm~\ref{alg:validator-recovery-cert} by triggering
$\bot$-votes when the max support $q$ inside an $n - f$ certificate is less than $n - 3f$
(lines~\ref{line:check-no-majority}--\ref{line:sign-bot}).
\end{proof}

\textbf{Recovery enables progress.} Finally, we show that a healing client can use the certificates from the previous lemma to construct a valid recovery transaction. Once constructed, the recovery transaction is non-conflicting and will be finalized within one round trip, unlocking the account.

\begin{lemma}[Recovery liveness for healing clients]
\label{lem:recovery-liveness}
Let a client be healing, and suppose its account becomes locked due to equivocation at some nonce
$k$. After the client heals (stops equivocating) and the network is in the synchronous period after
GST, the client can construct and finalize a recovery transaction within one round trip, thus
unlocking progress.
\end{lemma}

\begin{proof}
By Lemma~\ref{lem:notarized-forms}, for each nonce between the last finalized nonce and the current
signing nonce, validators can provide either (i) an $n - 3f$ certificate for a transaction with
majority support, or (ii) an $n - 3f$ certificate for $\bot$. The client collects this information
(Algorithms~\ref{alg:validator-recovery-rpc} and~\ref{alg:client-recovery}) and constructs a
recovery transaction $tx_{\mathsf{rec}}$ whose validation requires exactly those certificates
(Algorithm~\ref{alg:validator-recovery-tx}, \textsc{ValidateRecovery},
lines~\ref{line:check-tip-cert}--\ref{line:check-bot-cert}).

Once the client broadcasts $tx_{\mathsf{rec}}$, all honest validators accept and vote (it is
non-conflicting and locally verifiable). The client collects $n - f$ votes and finalizes
$tx_{\mathsf{rec}}$ within one round trip (Lemma~\ref{lem:fast-path-liveness}). Executing
$tx_{\mathsf{rec}}$ advances the account state and clears the lock
(Algorithm~\ref{alg:validator-recovery-cert}), allowing the client to resume normal operation.
\end{proof}

\begin{corollary}[Payment liveness for honest and healed clients]
\label{cor:merged-liveness}
After GST, any honest client, and any healing client after it has healed, can always transfer
funds: for any valid payment it wishes to issue, it can obtain an $(n-f)$ finality certificate.
Moreover, if the account is not locked, confirmation takes one network round trip; if the
account is locked, one recovery round trip suffices to unlock the account, after which the
payment confirms in one additional round trip.
\end{corollary}

\begin{proof}
Fix a client $a$ after GST.

If $a$'s account is not locked (i.e., the client submits a single non-conflicting transaction
for its current nonce), then the payment is confirmed within one network round trip by
Lemma~\ref{lem:fast-path-liveness}.

If $a$'s account is locked due to past equivocation, and $a$ is healing and has healed, then
Lemma~\ref{lem:recovery-liveness} guarantees that $a$ can construct and finalize a recovery transaction within one
network round trip, which clears the lock and advances progress. After that, the client can
submit a non-conflicting payment for its current nonce, which is confirmed within one
network round trip by Lemma~\ref{lem:fast-path-liveness}.
\end{proof}

\begin{theorem}[Liveness for honest and healed clients; responsiveness]
\label{thm:liveness}
After GST, the protocol is live for honest clients and for healing clients after they have
healed: such clients can always make progress and continue issuing payments. Moreover,
confirmation remains one network round trip in the optimistic case and during recovery,
and liveness depends on the actual message delay $\delta$ rather than a known bound $\Delta$,
i.e., the protocol is responsive.
\end{theorem}

\begin{proof}
Combine Lemmas~\ref{lem:fast-path-liveness} and~\ref{lem:recovery-liveness}. The responsiveness
claim follows the same intuition used in Simplex-style protocols: progress is paced by message
arrivals, not by waiting for a known $\Delta$.
\end{proof}
