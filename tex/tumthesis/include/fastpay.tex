\chapter{FastPay Protocol Overview}
\label{chap:fastpay}

We now describe a simplified version of the FastPay protocol~\cite{fastpay} that forms the basis for our recovery construction. FastPay is a Byzantine fault-tolerant payment system that achieves confirmation in a single round trip without requiring consensus among validators. The standard protocol operates with $n \geq 3f + 1$ validators, where $f$ is the maximum number of Byzantine validators. Our recovery extension (Chapter~\ref{chap:protocol}) requires the stronger assumption $n \geq 5f + 1$ to ensure safe recovery from equivocation.

\textbf{Certificates and quorums.}
A \emph{vote} is a signed message $\langle \mathsf{vote}, a, k, m \rangle_v$ from validator $v$, where $a$ is an account, $k$ is a nonce, and $m$ is either a transaction $tx$ or the symbol $\bot$.

A \emph{$q$-certificate} for account $a$ at nonce $k$ is a set of at least $q$ votes from distinct validators on the same $(a, k)$ pair (votes may be for different messages). A \emph{$q$-quorum certificate} (or simply $q$-quorum) is a $q$-certificate where all votes are for the same message $m$.

We use two quorum thresholds:
\begin{itemize}
    \item \textbf{Finality threshold:} $n - f$. A transaction with an $(n-f)$-quorum is \emph{finalized}.
    \item \textbf{Notarization threshold:} $n - 3f$. A transaction with an $(n-3f)$-quorum is \emph{notarized}. This weaker threshold is used for recovery (Chapter~\ref{chap:protocol}).
\end{itemize}

\textbf{Equivocation.}
A party \emph{equivocates} at $(a, k)$ if it signs two different non-$\bot$ messages for the same account $a$ and nonce $k$. Honest validators never equivocate. Byzantine validators and clients may equivocate arbitrarily.

\textbf{Validator protocol.}
Algorithm~\ref{alg:validator} shows the simplified validator logic.

\begin{algorithm}[h]
\caption{Honest Validator}\label{alg:validator}
\begin{algorithmic}[1]
\State \textbf{global} $\mathcal{V}$: validator set
\State \textbf{state} $\mathsf{account}[\cdot]$: mapping from client public key to $(\mathsf{balance}, \mathsf{nonce}, \mathsf{pending})$
\Statex
\Procedure{OnTransaction}{$tx, \sigma$}
    \State \textbf{verify} $\sigma$ is a valid signature from $tx.\mathsf{sender}$ on $tx$
    \State \textbf{require} $\mathsf{account}[tx.\mathsf{sender}].\mathsf{pending} = \mathsf{false}$
    \State \textbf{require} $\mathsf{account}[tx.\mathsf{sender}].\mathsf{nonce} = tx.\mathsf{nonce}$
    \State \textbf{require} $\mathsf{account}[tx.\mathsf{sender}].\mathsf{balance} \geq tx.\mathsf{amount}$
    \State $\mathsf{account}[tx.\mathsf{sender}].\mathsf{pending} \gets \mathsf{true}$
    \State broadcast $\langle \mathsf{vote}, tx \rangle_v$ to $\mathcal{V}$ and listening clients
\EndProcedure
\Statex
\Procedure{OnCertificate}{$tx, C$}
    \State \textbf{require} $C$ is a valid $(n-f)$-quorum on $tx$
    \State \textbf{require} $\mathsf{account}[tx.\mathsf{sender}].\mathsf{nonce} = tx.\mathsf{nonce}$
    \State $\mathsf{account}[tx.\mathsf{sender}].\mathsf{pending} \gets \mathsf{false}$
    \State $\mathsf{account}[tx.\mathsf{sender}].\mathsf{nonce} \gets tx.\mathsf{nonce} + 1$
    \State $\mathsf{account}[tx.\mathsf{sender}].\mathsf{balance} \mathrel{-}= tx.\mathsf{amount}$
    \State $\mathsf{account}[tx.\mathsf{recipient}].\mathsf{balance} \mathrel{+}= tx.\mathsf{amount}$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Client protocol.}
Algorithm~\ref{alg:client} shows the simplified client logic.

\begin{algorithm}[h]
\caption{Honest Client}\label{alg:client}
\begin{algorithmic}[1]
\State \textbf{global} $\mathcal{V}$: validator set
\State \textbf{state} $\mathsf{nonce}$: local transaction sequence number
\Statex
\Procedure{SendTransaction}{$\mathsf{to}, \mathsf{amount}$}
    \State $tx \gets (\mathsf{self}, \mathsf{to}, \mathsf{amount}, \mathsf{nonce}, \emptyset)$
    \State $\mathsf{nonce} \gets \mathsf{nonce} + 1$
    \State broadcast $(tx, \langle tx \rangle_{\mathsf{self}})$ to $\mathcal{V}$
    \State wait for $n - f$ valid votes \Comment{certificate formed by validators}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Transaction flow.}
A transaction proceeds in three phases:
\begin{enumerate}
    \item \textbf{Validation.} The client constructs a transaction, signs it, and broadcasts it to all validators. Each validator checks that (i) the signature is valid, (ii) no transaction is currently pending for this account, (iii) the nonce matches the expected value, and (iv) the balance is sufficient. If all checks pass, the validator sets the pending flag and broadcasts its signed vote to all validators and listening clients.
    \item \textbf{Confirmation.} Once the client observes $n - f$ votes, the transaction is considered finalized, even though the state has not yet been updated. This is the confirmation latency of the protocol: $2\delta$ or one network round trip (client to validators and back).
    \item \textbf{Execution.} Validators assemble votes into a certificate and broadcast it. Upon receiving a valid certificate, validators execute the transaction: they clear the pending flag, increment the nonce, and update balances.
\end{enumerate}

\textbf{Note on vote dissemination.}
Unlike the original FastPay paper where clients assemble and broadcast certificates, we have validators broadcast votes to all validators and listening clients. This simplifies client logic without affecting safety or liveness.

\textbf{Safety.}
Safety relies on the fact that each validator votes for at most one transaction per nonce (enforced by the pending flag and nonce check). Since $n \geq 3f + 1$, any two $(n-f)$-quorums must intersect in at least $(n - f) + (n - f) - n = n - 2f \geq f + 1$ validators. With at most $f$ Byzantine validators, any two quorums share at least one honest validator. An honest validator only votes once per nonce, so two conflicting certificates for the same nonce cannot both exist. This ensures that conflicting transactions cannot both be finalized.

\textbf{Liveness.}
Liveness holds for honest clients that do not equivocate. If a client sends a single transaction for each nonce, it will eventually collect $n - f$ votes (since at least $n - f$ validators are honest and will respond). The client can then form a certificate and finalize the transaction. Critically, if a client sends conflicting transactions for the same nonce, different validators may vote for different transactions, and neither may reach $n - f$ votes-the account becomes locked.

\textbf{Permanent locking from equivocation.}
Client equivocation leads to permanent loss of liveness. Consider a client that broadcasts two conflicting transactions $tx$ and $tx'$ with the same nonce. With $n = 3f + 1$ validators, suppose $f + 1$ honest validators vote for $tx$ and $f$ honest validators vote for $tx'$ (the remaining $f$ are Byzantine). The client can collect at most $2f + 1$ votes for $tx$ and at most $3f$ votes for $tx'$. If Byzantine validators split their votes or abstain, neither transaction reaches the $(n-f)$-quorum required for finality. The account is now \emph{locked}: the pending flag is set at all honest validators, no certificate can be formed, and no future transaction with a higher nonce can proceed.
