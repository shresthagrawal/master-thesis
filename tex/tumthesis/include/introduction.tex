\chapter{Introduction}
\label{chap:introduction}

Blockchains suffer from a scalability problem. During periods of high demand, transaction fees have repeatedly spiked and networks have become slow or unusable. The most widely adopted response has been Layer-2 (L2) scaling solutions, such as rollups. Rollups move execution off-chain while relying on a single sequencer to order transactions, execute them, and extract the new state. The sequencer posts these transaction batches along with the resulting states to the underlying Layer-1 blockchain. While effective in practice, this design introduces centralization and worsens finality guarantees, as users must still wait for transactions to be posted and finalized on-chain to obtain full security. 
\za{this is incorrect. the finality would be the same in a ZK rollup but the ZK computations drives centralization; while in the optimistic rollups the finality is not the same. My proposal is: "While effective in practice, rollups either introduce centralization (cite ZK-rollups) when the sequencer must provide a proof of validity for the resulting state, or worsen finality guarantees in optimistic designs where the sequencer can post wrong states and thus the users must wait out a dispute period (cite arbitrum).}

An alternative approach is to relax the requirement for strong-consensus or total ordering altogether. This tradeoff is well understood in distributed systems, where asynchronous execution sacrifices strong consistency for eventual consistency to achieve better performance \za{undefined strong consistency, and eventual cons. explain better}. In the blockchain setting, it has been shown that not all applications require consensus: in particular, BFT payment systems can be implemented without total ordering. This insight has led to a line of work on asynchronous Byzantine fault-tolerant protocols that avoid consensus.

These protocols achieve confirmation within a single network round trip and support throughput several orders of magnitude higher than consensus-based systems \za{give example, the reader does not know the magnitudes. Add citations to support it, e.g., fastpay?}. However, despite these advantages, asynchronous protocols have not seen meaningful production adoption.\za{is the asynchronous or the consensusless part wre care about? the last sentence seems to highlight that we care its async...}

A key limitation is fragility in the presence of faulty clients. Asynchronous \za{Consensusless! asynchronous protocols are irrelevant; the statement is wrong. } protocols typically rely on nonce-based sequencing to enforce local ordering. If a client equivocates by issuing multiple transactions with the same nonce, the affected state can become permanently locked. Such equivocation need not be malicious and can arise from crash faults, for example when a client restarts without remembering that it has already sent a transaction using a given nonce. 

Handling equivocation is particularly challenging in the Byzantine setting. Some honest parties may have already observed that a transaction is finalized, while others may have seen conflicting transactions and none of them finalised. Recovery must reconcile these views without confirming conflicting transactions or violating safety. This problem closely mirrors equivocation by a faulty leader in consensus protocols, which is resolved using view-change mechanisms. The Simplex protocol \za{cite simplex} provides a particularly simple and efficient view-change design for handling such equivocation. \za{too vague last sentence}

In this thesis, we present a fast-path recovery protocol for asynchronous systems that enables recovery from client equivocation without fallback consensus. Our construction operates in the $5f+1$ fault model and preserves confirmation latency of a single network round trip. We give a concrete construction extending a FastPay-style protocol \za{its the first time you mention Fastpay, mention it before so here it makes sense} with a recovery mechanism inspired by Simplex view change.

Once a client detects that it is locked, it collects $n-f$ validator attestations over the conflicting transactions and constructs a special recovery transaction that either selects a valid candidate transaction or skips the equivocated nonce. Validators can safely sign this recovery transaction without violating safety. Once the recovery transaction gathers sufficient votes, the referenced transaction chain is finalized. We implement the protocol and evaluate its performance, showing that latency and throughput remain unchanged relative to the original fast path \za{we need comparative evaluation showing no change}. We believe this work solves a cornerstone problem in the production deployment of asynchronous blockchain protocols \za{I wouldn't say asynchronous, I would remove it.}.
