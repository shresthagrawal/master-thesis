\chapter{Extending FastPay with Recovery}
\label{chap:protocol}

\section{Protocol Overview}
\label{sec:protocol-overview}

In this section, we progressively extend the FastPay construction to allow for full recovery. On a high level,
we would like a healing client to send a special \emph{recovery transaction} that allows validators to safely
release the pending state and move the client's nonce forward.

The main challenge is ensuring safety: previously confirmed transactions must not be reverted. Recall from
Chapter~\ref{chap:background} that a key property of FastPay is that a payment recipient can verify a quorum
certificate and be certain that the payment will not be reverted, even if the client is malicious. Our recovery
mechanism must preserve this property.

\textbf{Recovery to the transaction with majority support.}
Our first extension introduces a recovery transaction that points to a previous transaction called the \emph{tip} - the
transaction that is safe to recover to. The client provides an $(n-f)$-certificate with majority support for the
tip transaction. This certificate serves as proof that the tip transaction is the one that should be finalized.

\textbf{The $3f+1$ Model.}
Consider a concrete example with $n = 4$ validators and $f = 1$ Byzantine validator. A certificate requires
$n - f = 3$ votes. Suppose a malicious client constructs two conflicting transactions $\mathsf{tx}$ and $\mathsf{tx}'$
at the same nonce. The client sends $\mathsf{tx}$ to validators $\{V_1, V_2, V_4\}$ and $\mathsf{tx}'$ to validators
$\{V_3, V_4\}$, where $V_4$ is Byzantine and signs both transactions. The client can then:
\begin{enumerate}
    \item Obtain a finality certificate for $\mathsf{tx}$ with votes from $\{V_1, V_2, V_4\}$-a recipient of
        $\mathsf{tx}$ now considers the payment confirmed.
    \item Construct a conflicting $(n-f)$-certificate with votes $\{V_1, V_3, V_4\}$ where $\mathsf{tx}'$ has
        majority support (2 out of 3 votes from $V_3$ and $V_4$).
\end{enumerate}
If an honest client uses this certificate to recover with $\mathsf{tx}'$ as the tip, this violates safety:
the previously finalized transaction $\mathsf{tx}$ is reverted, invalidating a confirmed payment.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[
    tick/.style={font=\LARGE},
    bt/.style={tick, color=TUMBlue},
    gt/.style={tick, color=TUMGreen},
    byzmark/.style={font=\scriptsize, inner sep=0pt},
    lbl/.style={font=\small, align=center}
]

% Certificate A (finalized)
\draw[thick] (-1.1,-0.5) rectangle (1.1,0.5);
\node[bt] at (-0.6,0) {\checkmark};
\node[bt] at (0,0) {\checkmark};
\node[bt] at (0.6,0) {\checkmark};
\node[color=red, font=\scriptsize] at (0.85,0.25) {$\bigstar$};
\node[lbl] at (0,-1) {certificate A (finalized)};

% Certificate B
\draw[thick, dashed] (3.4,-0.5) rectangle (5.6,0.5);
\node[bt] at (3.9,0) {\checkmark};
\node[bt] at (4.5,0) {\checkmark};
\node[color=red, font=\scriptsize] at (4.75,0.25) {$\bigstar$};
\node[gt] at (5.1,0) {\checkmark};
\node[lbl] at (4.5,-1) {certificate B\\\textit{is it locked?}};

% Certificate C
\draw[thick, dashed] (7.4,-0.5) rectangle (9.6,0.5);
\node[bt] at (7.9,0) {\checkmark};
\node[color=red, font=\scriptsize] at (8.15,0.25) {$\bigstar$};
\node[gt] at (8.5,0) {\checkmark};
\node[gt] at (9.1,0) {\checkmark};
\node[lbl] at (8.5,-1) {certificate C\\\textit{is it locked?}};

% Global view
% Solid box covering first 3 ticks (positions 1, 2, 3)
\draw[thick] (2.9,-3) rectangle (4.9,-2);
% Dotted box covering last 3 ticks (positions 2, 3, 4)
\draw[thick, dashed] (3.4,-3) rectangle (5.4,-2);
% Position 1: blue
\node[bt] at (3.4,-2.5) {\checkmark};
% Position 2: blue
\node[bt] at (3.9,-2.5) {\checkmark};
% Position 3: blue+green stacked (Byzantine voter)
\node[bt] at (4.4,-2.35) {\checkmark};
\node[gt] at (4.4,-2.65) {\checkmark};
% Red star for the malicious vote
\node[color=red, font=\scriptsize] at (4.65,-2.1) {$\bigstar$};
% Position 4: green
\node[gt] at (4.9,-2.5) {\checkmark};
\node[lbl] at (4.15,-3.5) {global view};

\end{tikzpicture}
\caption{The strawman recovery problem in the $3f+1$ model. Certificate A is finalized with 3 votes (including Byzantine validator marked with {\color{red}$\bigstar$}).
Certificates B and C show two possible $(n-f)$-certificates where the conflicting transaction $\mathsf{tx}'$ has majority support.
The global view reveals that the Byzantine validator signed both transactions, enabling a safety violation.}
\label{fig:strawman-attack}
\end{figure}

\textbf{The $5f+1$ Model.}
Consider the same scenario in the $5f+1$ model with $n = 6$ validators and $f = 1$ Byzantine validator. A certificate
now requires $n - f = 5$ votes. To obtain a finality certificate for $\mathsf{tx}$, the client must obtain votes from
4 honest validators plus the 1 Byzantine validator it controls, say $\{V_1, V_2, V_3, V_4, V_6\}$ where $V_6$ is Byzantine.
If the client attempts to create a conflicting certificate for $\mathsf{tx}'$, only one honest validator $V_5$ remains
who has not voted for $\mathsf{tx}$. Therefore, any $(n-f)$-certificate must contain at least 3 votes for $\mathsf{tx}$
(a majority) and can have at most 2 votes for $\mathsf{tx}'$.

More generally, any two $(n-f)$-certificates must share at least $(n-f) + (n-f) - n = n - 2f = 3f + 1$ validators.
Of these $3f + 1$ shared validators, at most $f$ are Byzantine, so at least $2f + 1$ are honest. Since honest
validators never sign conflicting transactions, any two $(n-f)$-certificates share an honest majority that voted
for the same transaction. This guarantees safe recovery: if a transaction $\mathsf{tx}$ ever receives a finality
certificate, then every $(n-f)$-certificate will have majority support for $\mathsf{tx}$.

\begin{figure}[ht]
\centering
\begin{tikzpicture}[
    tick/.style={font=\LARGE},
    bt/.style={tick, color=TUMBlue},
    gt/.style={tick, color=TUMGreen},
    lbl/.style={font=\small, align=center}
]

% Certificate A (5 votes - finalized)
\draw[thick] (-1.4,-0.5) rectangle (1.6,0.5);
\node[bt] at (-1.0,0) {\checkmark};
\node[bt] at (-0.4,0) {\checkmark};
\node[bt] at (0.2,0) {\checkmark};
\node[bt] at (0.8,0) {\checkmark};
\node[bt] at (1.2,0) {\checkmark};
\node[color=red, font=\scriptsize] at (1.45,0.25) {$\bigstar$};
\node[lbl] at (0.1,-1) {certificate A (5 votes, finalized)};

% Certificate B (5 votes: 3 blue + 2 green)
\draw[thick, dashed] (4.0,-0.5) rectangle (7.0,0.5);
\node[bt] at (4.5,0) {\checkmark};
\node[bt] at (5.1,0) {\checkmark};
\node[bt] at (5.7,0) {\checkmark};
\node[gt] at (6.3,0) {\checkmark};
\node[color=red, font=\scriptsize] at (6.55,0.25) {$\bigstar$};
\node[gt] at (6.7,0) {\checkmark};
\node[lbl] at (5.5,-1) {certificate B (5 votes, 3 blue)};

% Global view (6 validators: 4 blue, 1 blue+green, 1 green)
% Solid box around first 5 validators
\draw[thick] (1.3,-3) rectangle (4.7,-2);
% Dotted box around last 5 validators
\draw[thick, dashed] (1.9,-3) rectangle (5.3,-2);
% Position 1: blue (solid only)
\node[bt] at (1.8,-2.5) {\checkmark};
% Position 2: blue (both boxes)
\node[bt] at (2.4,-2.5) {\checkmark};
% Position 3: blue (both boxes)
\node[bt] at (3.0,-2.5) {\checkmark};
% Position 4: blue (both boxes)
\node[bt] at (3.6,-2.5) {\checkmark};
% Position 5: blue+green stacked (both boxes, Byzantine)
\node[bt] at (4.2,-2.35) {\checkmark};
\node[gt] at (4.2,-2.65) {\checkmark};
\node[color=red, font=\scriptsize] at (4.45,-2.1) {$\bigstar$};
% Position 6: green (dotted only)
\node[gt] at (4.8,-2.5) {\checkmark};
\node[lbl] at (3.3,-3.5) {global view (6 validators)};

\end{tikzpicture}
\caption{The $5f+1$ model enables safe recovery. Certificate B has 5 votes but must contain at least 3 validators
(blue) who also voted for $\mathsf{tx}$ in certificate A. The Byzantine validator is marked with {\color{red}$\bigstar$}.}
\label{fig:5f1-safe}
\end{figure}

This property forms the basis for our recovery mechanism. When a client's account becomes locked due to
a failed transaction at nonce $k$, the client can submit a \emph{recovery transaction} with the next nonce,
the transaction to recover, and a past $(n-f)$-certificate that shows majority votes for that transaction.
Such a certificate guarantees that no conflicting $(n-f)$-finality certificate can exist for a different
transaction $\mathsf{tx}'$. Note that multiple such certificate-transaction pairs may exist, but it is safe
to recover with any of them. Validators verify the certificate and safely advance the account's nonce,
allowing the client to resume transacting.

\textbf{Signing $\bot$ in the absence of majority support.}
It is not guaranteed that an $(n-f)$-certificate with majority support for a single transaction always exists.
Consider a scenario where a malicious client sends a different transaction to each validator. In this case,
no transaction receives enough votes to form a quorum, and no $(n-f)$-certificate has majority support for
any single transaction.

To handle this case, if a client shows an $(n-f)$-certificate with no majority transaction, validators sign
$\bot$ (bottom) signaling that there is no transaction that could be finalized for this nonce. When a client
presents an $(n-f)$-certificate where $\bot$ has majority support, validators can safely skip that nonce and
move forward. As a result, not all nonces will have a finality certificate - some may be skipped during recovery.
When a higher nonce is finalized, all previous nonces are also considered finalized. 

\textbf{Recursive Recovery.}
A subtle issue arises when a malicious client creates conflicting recovery transactions that point to different
tips. As discussed earlier, multiple $(n-f)$-certificates with different majority support can exist, so a
malicious client can create valid but conflicting recovery transactions. This causes the account to become
locked again during the recovery process itself. To handle this, we allow a recovery transaction to point
to a previous recovery transaction, not just a normal transaction.

Consider an example: suppose a client's account is locked at nonce $k$ with a normal transaction $\mathsf{tx}_k$
that has an $(n-3f)$-certificate. The client initiates recovery at nonce $k+1$, but the recovery also fails
due to conflicting recovery transactions. The client must now recover again at nonce $k+2$. This recovery
transaction at nonce $k+2$ can either:
\begin{itemize}
    \item Point to a recovery transaction at nonce $k+1$ if one has an $(n-3f)$-certificate, or
    \item Point back to the original transaction $\mathsf{tx}_k$ at nonce $k$, along with a $\bot$ certificate
        for nonce $k+1$ indicating it should be skipped.
\end{itemize}

More generally, a recovery transaction must point to a non-$\bot$ transaction (either recovery or normal)
that has an $(n-3f)$-certificate, along with $\bot$ certificates for any intermediate nonces that should
be skipped. This creates a chain of recovery transactions that eventually ends at a normal transaction.
Skipping nonces with $\bot$ certificates is safe because they guarantee that no transaction was finalized
at those nonces.


\section{Complete Protocol and Pseudocode}
\label{sec:complete-protocol}

We now present the complete protocol with recovery support. In the optimistic case where no account lock occurs,
the protocol follows the same flow as standard FastPay: the client sends a transaction, collects $n-f$ votes
to form a certificate, and broadcasts the certificate to finalize the transaction.

\textbf{Recovery Contract Address and Transaction Structure.}
We designate a special address $\mathsf{recovery\_contract}$ as a precompiled contract for handling recovery
transactions. This approach maintains backward compatibility with existing Ethereum wallets and tooling, as
the transaction structure remains unchanged - clients simply send a transaction to the recovery contract address.
A recovery transaction has the following structure:
\[
tx_{\mathsf{rec}} = (\mathsf{sender}, \mathsf{recovery\_contract}, 0, \mathsf{nonce}, \mathsf{tip}),
\]
where $\mathsf{tip}$ is a reference to the tip transaction to recover to. The amount field is zero since
recovery transactions do not transfer value. Validators look up the required certificates from their local
state to verify the recovery is valid.

\textbf{Validator Protocol.}
Algorithms~\ref{alg:validator-recovery-tx} and~\ref{alg:validator-recovery-cert} present the extended validator
protocol. Unlike standard FastPay, validators now maintain two separate counters: $\mathsf{nonce}$ tracks the
next nonce to sign, while $\mathsf{finalised}$ tracks the last finalized nonce (line~\ref{line:account-state}).
Validators also store all received votes in $\mathsf{votes}[a][k]$ (line~\ref{line:vote-store}) to support
certificate construction and recovery queries.

When a validator receives a transaction (Algorithm~\ref{alg:validator-recovery-tx}), it first verifies the
signature (line~\ref{line:verify-sig}) and checks that the account is not pending (line~\ref{line:check-pending})
and the nonce matches (line~\ref{line:check-nonce}). The validator then distinguishes between normal payments
and recovery transactions based on the recipient address (line~\ref{line:check-recovery}). For normal payments,
\textsc{ValidatePayment} checks that the previous nonce was finalized (line~\ref{line:check-finalised}) and
sufficient balance exists (line~\ref{line:check-balance}). For recovery transactions, \textsc{ValidateRecovery}
verifies that the tip transaction has an $(n-3f)$-certificate (line~\ref{line:check-tip-cert}) and that all
intermediate nonces have $\bot$ certificates (lines~\ref{line:check-bot-loop}--\ref{line:check-bot-cert}). After
validation, the validator marks the account as pending (line~\ref{line:set-pending}), processes its own vote
via \textsc{OnVote}, and broadcasts the vote (line~\ref{line:broadcast-vote}).

When a validator receives a vote (Algorithm~\ref{alg:validator-recovery-cert}, \textsc{OnVote}), it verifies
the signature (line~\ref{line:verify-vote}), stores the vote, and calls \textsc{ProcessCertificate}
(line~\ref{line:call-process-cert}). The \textsc{ProcessCertificate} procedure extracts the transaction with
maximum quorum support (line~\ref{line:extract-quorum}). If $n-f$ votes have been collected but no transaction
has reached the notarisation quorum of $n-3f$ (line~\ref{line:check-no-majority}), the validator signs $\bot$
(line~\ref{line:sign-bot}), signaling that no transaction can be finalized at this nonce. If notarisation
quorum is reached and the account is pending (line~\ref{line:advance-nonce-pending}), the validator advances
the nonce. When finality quorum of $n-f$ votes is reached (line~\ref{line:check-finality}), the validator
finalizes the transaction and updates the finalised counter (line~\ref{line:update-finalised}). For recovery
transactions, \textsc{GetTxChainStart} (line~\ref{line:get-tx-chain}) follows the chain back to the original
tip transaction that should be executed.

\textbf{Client Protocol.}
Algorithm~\ref{alg:client-recovery} presents the client-side logic. The \textsc{SendTransaction} procedure
follows the standard FastPay flow: construct a transaction, broadcast it to collect $n-f$ votes, and broadcast
the resulting certificate.

The \textsc{InitiateRecovery} procedure is invoked when the client detects that its account is locked. The
client queries a fullnode for the current nonce and a non-$\bot$ transaction to use as the tip. The client
constructs a recovery transaction that references the tip, then follows the same vote collection and certificate
broadcast process as normal transactions.

\begin{algorithm}[ht]
\caption{Validator with Recovery - Transaction Handling}\label{alg:validator-recovery-tx}
\begin{algorithmic}[1]
\State \textbf{global} $\mathcal{V}$: validator set, $\mathsf{recovery\_contract}$: recovery address
\State \textbf{state} $\mathsf{account}[\cdot]$: mapping from public key to $(\mathsf{balance}, \mathsf{nonce}, \mathsf{pending}, \mathsf{finalised})$ \label{line:account-state}
\State \textbf{state} $\mathsf{votes}[\cdot][\cdot]$: mapping from $(a, k)$ to list of votes \label{line:vote-store}
\Statex
\Procedure{OnTransaction}{$tx, \sigma$}
    \State \textbf{verify} $\sigma$ is valid signature from $tx.\mathsf{sender}$ on $tx$ \label{line:verify-sig}
    \State \textbf{require} $\mathsf{account}[tx.\mathsf{sender}].\mathsf{pending} = \mathsf{false}$ \label{line:check-pending}
    \State \textbf{require} $tx.\mathsf{nonce} = \mathsf{account}[tx.\mathsf{sender}].\mathsf{nonce}$ \label{line:check-nonce}
    \If{$tx.\mathsf{recipient} = \mathsf{recovery\_contract}$} \label{line:check-recovery}
        \State \Call{ValidateRecovery}{$tx$}
    \Else
        \State \Call{ValidatePayment}{$tx$}
    \EndIf
    \State $\mathsf{account}[tx.\mathsf{sender}].\mathsf{pending} \gets \mathsf{true}$ \label{line:set-pending}
    \State $\mathsf{vote} \gets \langle \mathsf{vote}, tx.\mathsf{sender}, tx.\mathsf{nonce}, tx \rangle_v$
    \State \Call{OnVote}{$\mathsf{vote}$}
    \State broadcast $\mathsf{vote}$ to $\mathcal{V}$ and listening clients \label{line:broadcast-vote}
\EndProcedure
\Statex
\Procedure{ValidateRecovery}{$tx$}
    \State $\mathsf{tip} \gets tx.\mathsf{data}.\mathsf{tip}$
    \State \textbf{require} $\exists$ $(n-3f)$-certificate for $\mathsf{tip}$ at nonce $\mathsf{tip}.\mathsf{nonce}$ \label{line:check-tip-cert}
    \For{$k \gets \mathsf{tip}.\mathsf{nonce} + 1$ \textbf{to} $tx.\mathsf{nonce} - 1$} \label{line:check-bot-loop}
        \State \textbf{require} $\exists$ $(n-3f)$-certificate for $\bot$ at nonce $k$ \label{line:check-bot-cert}
    \EndFor
\EndProcedure
\Statex
\Procedure{ValidatePayment}{$tx$}
    \State \textbf{require} $\mathsf{account}[tx.\mathsf{sender}].\mathsf{finalised} = tx.\mathsf{nonce} - 1$ \label{line:check-finalised}
    \State \textbf{require} $\mathsf{account}[tx.\mathsf{sender}].\mathsf{balance} \geq tx.\mathsf{amount}$ \label{line:check-balance}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[ht]
\caption{Validator with Recovery - Vote and Certificate Handling}\label{alg:validator-recovery-cert}
\begin{algorithmic}[1]
\Procedure{OnVote}{$\mathsf{vote}$}
    \State \textbf{verify} $\mathsf{vote}$ has valid signature from validator in $\mathcal{V}$ \label{line:verify-vote}
    \State $a \gets \mathsf{vote}.\mathsf{account}$; $k \gets \mathsf{vote}.\mathsf{nonce}$
    \If{vote is non-$\bot$ and validator already voted at $(a, k)$}
        \State \Return \Comment{each validator votes at most once per nonce}
    \EndIf
    \If{vote is $\bot$ and validator already voted $\bot$ at $(a, k)$}
        \State \Return \Comment{ignore duplicate $\bot$ votes}
    \EndIf
    \State append $\mathsf{vote}$ to $\mathsf{votes}[a][k]$
    \State \Call{ProcessCertificate}{$a, k$} \label{line:call-process-cert}
\EndProcedure
\Statex
\Procedure{ProcessCertificate}{$a, k$} \label{line:process-cert}
    \State $(q, tx) \gets \text{max quorum in } \mathsf{votes}[a][k]$ \label{line:extract-quorum}
    \Statex
    \If{$k = \mathsf{account}[a].\mathsf{nonce}$}
        \If{$q < n - 3f$ \textbf{and} $|\mathsf{votes}[a][k]| \geq n - f$ \textbf{and} not voted $\bot$} \label{line:check-no-majority}
            \Comment{no notarisation quorum but have $n-f$ votes}
            \State $\mathsf{account}[a].\mathsf{pending} \gets \mathsf{true}$
            \State $\mathsf{vote}_\bot \gets \langle \mathsf{vote}, a, k, \bot \rangle_v$ \label{line:sign-bot}
            \State \Call{OnVote}{$\mathsf{vote}_\bot$}
            \State broadcast $\mathsf{vote}_\bot$ to $\mathcal{V}$
            \State \Return
        \ElsIf{$q \geq n - 3f$ \textbf{and} $\mathsf{account}[a].\mathsf{pending}$} \label{line:advance-nonce-pending}
            \State $\mathsf{account}[a].\mathsf{nonce} \gets k + 1$
            \State $\mathsf{account}[a].\mathsf{pending} \gets \mathsf{false}$
        \EndIf
    \EndIf
    \Statex
    \If{$q \geq n - f$ \textbf{and} $k > \mathsf{account}[a].\mathsf{finalised}$ \textbf{and} $tx \neq \bot$} \label{line:check-finality}
        \State $tx_{\mathsf{orig}} \gets \Call{GetTxChainStart}{tx}$ \label{line:get-chain-start}
        \If{$tx_{\mathsf{orig}}.\mathsf{nonce} = \mathsf{account}[a].\mathsf{finalised}$ \textbf{or} $tx_{\mathsf{orig}}.\mathsf{nonce} = \mathsf{account}[a].\mathsf{finalised} + 1$}
            \If{$tx_{\mathsf{orig}}.\mathsf{nonce} = \mathsf{account}[a].\mathsf{finalised} + 1$}
                \State \Call{ExecuteTransfer}{$tx_{\mathsf{orig}}$} \label{line:execute-transfer}
            \EndIf
            \State $\mathsf{account}[a].\mathsf{finalised} \gets k$ \label{line:update-finalised}
            \If{$k \geq \mathsf{account}[a].\mathsf{nonce}$}
                \State $\mathsf{account}[a].\mathsf{nonce} \gets k + 1$ \label{line:advance-nonce-final}
                \State $\mathsf{account}[a].\mathsf{pending} \gets \mathsf{false}$
            \EndIf
        \EndIf
    \EndIf
    \Statex
    \Comment{recursively process next nonce}
    \If{nonce was incremented}
        \State \Call{ProcessCertificate}{$a, \mathsf{account}[a].\mathsf{nonce}$}
    \EndIf
\EndProcedure
\Statex
\Procedure{ExecuteTransfer}{$tx$}
    \State $\mathsf{account}[tx.\mathsf{sender}].\mathsf{balance} \mathrel{-}= tx.\mathsf{amount}$
    \State $\mathsf{account}[tx.\mathsf{recipient}].\mathsf{balance} \mathrel{+}= tx.\mathsf{amount}$
\EndProcedure
\Statex
\Procedure{GetTxChainStart}{$tx$} \label{line:get-tx-chain}
    \If{$tx.\mathsf{recipient} = \mathsf{recovery\_contract}$}
        \State \Return \Call{GetTxChainStart}{$tx.\mathsf{data}.\mathsf{tip}$}
    \Else
        \State \Return $tx$
    \EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

Validators also expose a recovery RPC endpoint that returns the information needed for a client to
recover from a locked state. Algorithm~\ref{alg:validator-recovery-rpc} shows this procedure.

\begin{algorithm}[ht]
\caption{Validator Recovery RPC}\label{alg:validator-recovery-rpc}
\begin{algorithmic}[1]
\Procedure{GetRecoveryInfo}{$\mathsf{account}$}
    \State $k_f \gets \mathsf{account}[\mathsf{account}].\mathsf{finalised}$
    \State $k_n \gets \mathsf{account}[\mathsf{account}].\mathsf{nonce}$
    \State $tx_f \gets$ transaction finalized at nonce $k_f$ (or $\bot$ if none)
    \State $C_f \gets$ $(n-f)$-certificate for $tx_f$
    \State $\mathsf{chain} \gets []$
    \For{$k \gets k_f + 1$ \textbf{to} $k_n - 1$}
        \State $C_k \gets$ $(n-3f)$-certificate at nonce $k$ (for $tx$ or $\bot$)
        \State append $(k, C_k)$ to $\mathsf{chain}$
    \EndFor
    \State \Return $(k_f, tx_f, C_f, k_n, \mathsf{chain})$
\EndProcedure
\end{algorithmic}
\end{algorithm}

Algorithm~\ref{alg:client-recovery} presents the client-side logic. The \textsc{SendTransaction} procedure
follows the standard FastPay client protocol: construct a transaction and broadcast it to validators.
The \textsc{InitiateRecovery} procedure is invoked when the client detects that its account may be locked.
The client queries validators directly for recovery information, filters out responses with invalid
certificates, and selects the one with the highest nonce to use as the recovery point.

\begin{algorithm}[ht]
\caption{Client with Recovery}\label{alg:client-recovery}
\begin{algorithmic}[1]
\State \textbf{global} $\mathcal{V}$: validator set, $\mathsf{recovery\_contract}$: recovery address
\State \textbf{state} $\mathsf{nonce}$: next transaction nonce
\Statex
\Procedure{SendTransaction}{$\mathsf{to}, \mathsf{amount}$}
    \State $tx \gets (\mathsf{self}, \mathsf{to}, \mathsf{amount}, \mathsf{nonce}, \bot)$
    \State $\mathsf{nonce} \gets \mathsf{nonce} + 1$
    \State broadcast $(tx, \langle tx \rangle_{\mathsf{self}})$ to $\mathcal{V}$
    \State wait for $n - f$ valid votes \Comment{certificate formed by validators}
\EndProcedure
\Statex
\Procedure{InitiateRecovery}{}
    \State $\mathsf{responses} \gets$ query \Call{GetRecoveryInfo}{$\mathsf{self}$} from each $v \in \mathcal{V}$
    \State filter $\mathsf{responses}$ to keep only those with valid certificates
    \State $(k_f, tx_f, C_f, k_n, \mathsf{chain}) \gets$ response with highest $k_n$
    \State $tx_{\mathsf{tip}} \gets$ last non-$\bot$ transaction in $\mathsf{chain}$
    \If{$tx_{\mathsf{tip}} = \bot$}
        \State $tx_{\mathsf{tip}} \gets tx_f$ \Comment{all intermediate nonces are $\bot$, recover to last finalized}
    \EndIf
    \State $tx_{\mathsf{rec}} \gets (\mathsf{self}, \mathsf{recovery\_contract}, 0, k_n, tx_{\mathsf{tip}})$
    \State $\mathsf{nonce} \gets k_n + 1$
    \State broadcast $(tx_{\mathsf{rec}}, \langle tx_{\mathsf{rec}} \rangle_{\mathsf{self}})$ to $\mathcal{V}$
    \State wait for $n - f$ valid votes to form quorum certificate
\EndProcedure
\end{algorithmic}
\end{algorithm}

\section{Safety and Liveness Arguments}
\label{sec:safety-liveness}
\za{this should be a separate section called Security Analysis}
We state safety as a \emph{per-account common prefix} property: for each sender account $a$, validators maintain a local view of a chain of finalized actions indexed by the sender's nonce. Safety means that honest validators never disagree about this per-account chain.

\subsection{Per-Account Finalized Chain}

Fix an account $a$. Each validator $v_i$ maintains two counters: $\mathsf{finalised}[a]$ (the last finalized nonce) and $\mathsf{nonce}[a]$ (the next nonce it is willing to vote on). We define the \emph{per-account finalized chain} at validator $v_i$ as:
\[
L_i^a = (\ell_i^a(1), \ell_i^a(2), \ldots, \ell_i^a(\mathsf{finalised}_i[a])),
\]
where each entry $\ell_i^a(k)$ is either a transaction $tx_k$ (payment or recovery) with $(tx_k.\mathsf{sender} = a, tx_k.\mathsf{nonce} = k)$, or the symbol $\bot$ (nonce $k$ is skipped).

\begin{definition}[Per-account common prefix]
For any account $a$ and any two honest validators $v_i, v_j$, their chains $L_i^a$ and $L_j^a$ are prefix comparable. Equivalently, for all $k \leq \min(\mathsf{finalised}_i[a], \mathsf{finalised}_j[a])$: $\ell_i^a(k) = \ell_j^a(k)$.
\end{definition}

This implies standard confirmation safety: if a recipient observes a valid finality certificate for a payment $tx$ from $a$ at nonce $k$, then every honest validator's chain that reaches nonce $k$ contains $tx$ at position $k$.

\subsection{FastPay Without Recovery}

In the optimistic protocol, validators enforce local sequencing using the nonce check and pending flag. An honest validator votes for at most one payment transaction per $(a, k)$.

\begin{lemma}[Uniqueness at a nonce]
\label{lem:uniqueness}
For fixed $(a, k)$, there cannot exist two distinct non-$\bot$ transactions $tx \neq tx'$ such that both obtain finality quorums of size $n - f$.
\end{lemma}

\begin{proof}
Any two sets of size $n - f$ intersect in at least $(n-f) + (n-f) - n = n - 2f \geq f + 1$ validators (for $n \geq 3f + 1$). At least one is honest and cannot vote for two different non-$\bot$ transactions at the same $(a, k)$.
\end{proof}

\subsection{Recovery Preserves Common Prefix}

Recovery introduces skipping nonces ($\bot$ entries) and finalizing recovery transactions that execute earlier payments. We must show: (A) recovery transactions do not fork at their own nonce, and (B) recovery cannot revert previously confirmed payments.

\textbf{(A) No fork at recovery nonce.} A recovery transaction is subject to the same pending and nonce checks as payments. By Lemma~\ref{lem:uniqueness}, two distinct non-$\bot$ transactions (payment or recovery) cannot both obtain finality quorums at the same $(a, k)$.

\textbf{(B) Recovery cannot change finalized entries.} The $5f+1$ model ensures that if any transaction was finalized, a conflicting tip cannot be justified.

\begin{lemma}[Finalized transactions block conflicting tips]
\label{lem:no-conflicting-tip}
Assume $n \geq 5f + 1$. If a transaction $tx$ at $(a, k)$ has a finality quorum of size $n - f$, then no conflicting transaction $tx' \neq tx$ at $(a, k)$ can obtain an $(n - 3f)$-certificate.
\end{lemma}

\begin{proof}
Let $F$ be the $n - f$ validators who voted for $tx$. Suppose $tx'$ has a notarization set $N$ of size $n - 3f$. Then $|F \cap N| \geq (n-f) + (n-3f) - n = n - 4f \geq f + 1$ (since $n \geq 5f + 1$). Thus $F \cap N$ contains at least one honest validator who cannot vote for two different transactions at $(a, k)$.
\end{proof}

Since \textsc{ValidateRecovery} requires an $(n-3f)$-certificate for the tip, a recovery transaction cannot point to a conflicting transaction if the original was finalized.

\begin{lemma}[Skipping is safe]
\label{lem:skip-safe}
Assume $n \geq 5f + 1$. If an $(n - 3f)$-certificate for $\bot$ exists at $(a, k)$, then no transaction at nonce $k$ can be finalized.
\end{lemma}

\begin{proof}
Honest validators sign $\bot$ only after observing an $(n-f)$-certificate with no value reaching $n - 3f$ support. In the $5f+1$ model, if any transaction had an $(n-f)$-finality quorum, any $(n-f)$-certificate must contain at least $n - 3f$ votes for that transaction. Hence observing no $n - 3f$ support implies no finality occurred.
\end{proof}

\begin{theorem}[Per-account common prefix safety]
\label{thm:safety}
Assume $n \geq 5f + 1$. For any account $a$, the protocol maintains per-account common prefix: for any two honest validators $v_i, v_j$, their chains $L_i^a$ and $L_j^a$ are prefix comparable.
\end{theorem}

\begin{proof}
Consider the first nonce $k$ where two honest validators disagree. Disagreement at $k$ can only arise in three ways:
\begin{enumerate}
    \item Two different non-$\bot$ transactions both finalized via the fast path: impossible by Lemma~\ref{lem:uniqueness}.
    \item One validator has $\bot$ and another has a non-$\bot$ transaction (via recovery): impossible by Lemma~\ref{lem:skip-safe}, since a $\bot$ certificate implies no transaction was finalized.
    \item Two different non-$\bot$ transactions finalized via recovery with different tips: impossible by Lemma~\ref{lem:no-conflicting-tip}, since conflicting tips cannot both have $(n-3f)$-certificates.
\end{enumerate}
No such disagreement nonce $k$ exists.
\end{proof}
\za{this should have a corollary that say that the above gives you the SMR safty defintions that needs to be added in your Sec.2! }

\subsection{Liveness}
\za{Add intuition above lemmas, saying below we prove that XXX..before every lemma so one can skip the lemmas if they want to and still know wha toyu do.}
We sketch liveness in two layers: (i) progress when there is no equivocation, and (ii)
recovery-driven progress for healing clients after equivocation.

\begin{lemma}[Fast-path liveness for non-conflicting transactions]
\label{lem:fast-path-liveness}
After GST (partial synchrony), if a client submits a single non-conflicting transaction $tx$ for
the current nonce, then the client obtains $n - f$ votes within one network round trip (up to
message delay $\delta$), and the transaction can be finalized.
\end{lemma}

\begin{proof}
At least $n - f$ validators are honest and will accept and vote for $tx$
(Algorithm~\ref{alg:validator-recovery-tx}). Votes are disseminated to the client (and propagated
among validators), so the client collects $n - f$ votes within one round trip in the synchronous
period. This matches the standard FastPay ``client collects a quorum of signatures'' pattern.
\end{proof}

\begin{lemma}[A notarized value always forms for a stuck nonce]
\label{lem:notarized-forms}
Assume $n \geq 5f + 1$. For any nonce $k$, if no transaction reaches finality at $k$, then
eventually an $n - 3f$ notarization certificate forms for either (i) some transaction $tx$ with
majority support, or (ii) $\bot$.
\end{lemma}

\begin{proof}
This is the Simplex-style ``prevent getting stuck'' argument: when parties observe $n - f$ votes
without any $n - 3f$ certificate, they can safely vote for $\bot$, which guarantees that a
certificate (possibly for $\bot$) eventually forms.

Our protocol implements this mechanism in Algorithm~\ref{alg:validator-recovery-cert} by triggering
$\bot$-votes when the max support $q$ inside an $n - f$ certificate is less than $n - 3f$
(lines~\ref{line:check-no-majority}--\ref{line:sign-bot}).
\end{proof}

\begin{lemma}[Recovery liveness for healing clients]
\label{lem:recovery-liveness}
Let a client be healing, and suppose its account becomes locked due to equivocation at some nonce
$k$. After the client heals (stops equivocating) and the network is in the synchronous period after
GST, the client can construct and finalize a recovery transaction within one round trip, thus
unlocking progress.
\end{lemma}

\begin{proof}
By Lemma~\ref{lem:notarized-forms}, for each nonce between the last finalized nonce and the current
signing nonce, validators can provide either (i) an $n - 3f$ certificate for a transaction with
majority support, or (ii) an $n - 3f$ certificate for $\bot$. The client collects this information
(Algorithms~\ref{alg:validator-recovery-rpc} and~\ref{alg:client-recovery}) and constructs a
recovery transaction $tx_{\mathsf{rec}}$ whose validation requires exactly those certificates
(Algorithm~\ref{alg:validator-recovery-tx}, \textsc{ValidateRecovery},
lines~\ref{line:check-tip-cert}--\ref{line:check-bot-cert}).

Once the client broadcasts $tx_{\mathsf{rec}}$, all honest validators accept and vote (it is
non-conflicting and locally verifiable). The client collects $n - f$ votes and finalizes
$tx_{\mathsf{rec}}$ within one round trip (Lemma~\ref{lem:fast-path-liveness}). Executing
$tx_{\mathsf{rec}}$ advances the account state and clears the lock
(Algorithm~\ref{alg:validator-recovery-cert}), allowing the client to resume normal operation.
\end{proof}

\begin{theorem}[Liveness for healing clients; responsiveness]
\label{thm:liveness}
After GST, the protocol is live for healing clients: any healing client eventually makes progress
(its nonce advances, and it can continue issuing transactions). Moreover, confirmation remains one
network round trip in the optimistic case and during recovery, and liveness depends on the actual
message delay $\delta$ rather than a known bound $\Delta$, i.e., the protocol is responsive.
\end{theorem}

\begin{proof}
Combine Lemmas~\ref{lem:fast-path-liveness} and~\ref{lem:recovery-liveness}. The responsiveness
claim follows the same intuition used in Simplex-style protocols: progress is paced by message
arrivals, not by waiting for a known $\Delta$.
\end{proof}
\za{is this what you promised in section 2 that you will prove? there needs to be a mapping.}

\section{Extending to Other Asynchronous Protocols}
\label{sec:applicability}

The recovery mechanism presented in this thesis extends naturally to more expressive asynchronous protocols.
Sui Lutris~\cite{sui-lutris} generalizes FastPay from simple balance transfers to arbitrary single-writer
objects. In Lutris, each object has an owner, and only the owner can initiate transactions that modify
the object. Similar to FastPay, validators check that the objects referenced in a transaction are owned
by the sender and apply the state transition function sequentially based on the sender's nonce.

The recovery protocol remains exactly the same - only the validation and execution functions change. Instead
of checking sufficient balance (line~\ref{line:check-balance}), validators verify object ownership. Instead
of updating balances (line~\ref{line:execute-transfer}), validators execute the smart contract in the VM
based on the finalized transaction. The protocol guarantees a consistent chain of transactions per account,
ensuring that all validators arrive at the same account state.


\za{this section is a bit weak, as everything so far is properly defined and here we claim an extension. its ok for now, i jsut leave the comment in case we have more time. its NOT a priority.}
