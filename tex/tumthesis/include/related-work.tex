\chapter{Related Work}
\label{chap:related-work}

This chapter surveys the work most relevant to our recovery protocol. 
We begin with BFT consensus protocols to understand their trade-offs, 
starting with state-of-the-art protocols in the optimal $3f+1$ model. 
We then examine protocols in the $5f+1$ model, as our construction operates 
under this threshold and it provides a fairer baseline. We then turn to 
consensusless protocols, which form the foundation of our work, and examine 
how existing systems handle accounts locked due to equivocation. Finally, 
we discuss view-change mechanisms in consensus protocols, as they closely 
relate to the concrete design of our recovery protocol. 

\section{Byzantine Consensus Protocols}
\label{sec:rw-bft-consensus}

Byzantine fault-tolerant (BFT) consensus protocols provide total ordering of
transactions across validators, tolerating up to $f$ Byzantine faults among $n >=
3f+1$ participants. PBFT~\cite{pbft} established the classical three-phase
commit pattern with $O(n^2)$ message complexity. Tendermint~\cite{tendermint}
simplified this for blockchains with round-based voting and timeout-driven view
changes but inherits multi-round latency. HotStuff~\cite{hotstuff} reduced
view change to linear message complexity and introduced pipelining, enabling
practical leader-based BFT at scale. Simplex~\cite{simplex} further simplified
the design by cleanly separating safety from progress, using $\bot$-voting to
skip faulty views within a single round trip.

All these protocols achieve strong consistency through total ordering, but at
the cost of multiple communication rounds per commit. A separate line of work
revisits the $5f+1$ fault model for fast Byzantine
consensus~\cite{fab-paxos, revisiting-5f}. Martin and Alvisi~\cite{fab-paxos}
showed that two-step Byzantine consensus requires $5f+1$ processes, later
refined to $5f-1$ by Kuznetsov et al.~\cite{revisiting-5f}. This model trades
a stricter fault threshold (20\% vs 33\%) for single-round-trip finality when
all validators are responsive, while gracefully degrading to slower paths under
partial participation. Building on these foundations, several recent protocols
exploit this tradeoff~\cite{minimmit, banyan, kudzu, hydrangea, alpenglow}.
Banyan~\cite{banyan} achieves single-round-trip confirmation with rotating
leaders. Kudzu~\cite{kudzu} provides high throughput through erasure-coded
block dissemination while maintaining a fast path. Hydrangea~\cite{hydrangea}
introduces a dual-mode commit mechanism tolerating both Byzantine and crash
faults. Alpenglow~\cite{alpenglow} applies these ideas to Solana's consensus
layer, achieving sub-second finality through dual-threshold voting.

\section{Consensusless Protocols}
\label{sec:rw-consensusless-protocols}

Asset transfers and other restricted state updates do not require total ordering. Instead, these workloads can be finalized
using local sequencing and quorum certificates, avoiding the latency and coordination overhead of
global consensus.

The expressiveness of consensusless protocols depends on the type of state being updated. Three broad classes emerge: (1) \emph{commutative multi-writer state}, where updates can be applied in any order (e.g., deposit-only balances, CRDTs); (2) \emph{non-commutative single-writer state}, where a single owner sequences updates to avoid conflicts (e.g., account balances with withdrawals); and (3) \emph{non-commutative multi-writer state}, where concurrent updates from multiple writers require consensus-like coordination to resolve conflicts.

FastPay~\cite{fastpay} pioneered this approach with a permissioned payment protocol in which clients
collect validator votes to finalize transfers within a single network round trip, assuming
non-equivocation. ABC~\cite{abc} and follow-up systems further developed consensus-free
architectures, demonstrating that payments can be processed using broadcast-style primitives under
relaxed termination assumptions. Zef~\cite{zef} extends FastPay with privacy guarantees, while
Pod~\cite{pod} generalizes the approach into an accountable execution layer supporting optimal-latency
confirmation for a broad class of applications.

Subsequent work increases expressiveness while retaining consensusless fast paths. Sui
Lutris~\cite{sui-lutris} introduces an object-based model where single-writer objects bypass
consensus entirely, with shared objects falling back to consensus when necessary.
Cuttlefish~\cite{cuttlefish} extends this hybrid approach to collective objects.
Stingray~\cite{stingray} explores CRDT-like BFT objects, enabling concurrent updates to shared state
under bounded non-commutativity. CryptoConcurrency~\cite{cryptoconcurrency} analyzes asset transfers
with shared state, characterizing when consensus can be avoided and when stronger coordination is
required.

A common limitation across these designs is that fast-path liveness depends on the absence of
conflicts, typically enforced through client-side sequencing via nonces. Once equivocation occurs,
these protocols either lose liveness or must invoke additional recovery mechanisms.

\section{Fallback Consensus-Based Recovery}
\label{sec:fallback-consensus}

To address liveness failures caused by conflicts, many consensusless systems incorporate fallback
consensus mechanisms.

Sui Lutris~\cite{sui-lutris} explicitly invokes consensus when transactions involve shared objects
or conflicting accesses, ensuring safety at the cost of higher latency. Consensus on
Demand~\cite{consensus-on-demand} formalizes this approach by running consensus selectively only
when conflicts arise, rather than continuously, though this still reintroduces coordination overhead
and imposes stricter fault thresholds.

Other systems employ fallback consensus to recover from deadlock or equivocation.
CryptoConcurrency~\cite{cryptoconcurrency} relies on external consensus objects to resolve
overspending conflicts. Cuttlefish~\cite{cuttlefish} and Stingray~\cite{stingray} both introduce
unlock or FastUnlock mechanisms that ultimately depend on consensus or reconfiguration to restore
progress. In practice, these approaches often rely on periodic reconfiguration or global
synchronization to clear locked state.

While effective, fallback consensus undermines the core motivation for consensusless protocols: low
latency, simplicity, and avoidance of global coordination. This thesis differs from prior work by
eliminating fallback consensus for client equivocation recovery, while preserving fast-path
performance.

\section{Recovery as View Change}
\label{sec:rw-view-change}

Recovery from client equivocation in consensusless protocols closely resembles
view change in BFT consensus (Section~\ref{sec:rw-bft-consensus}). In
classical state-machine replication, a faulty leader may equivocate or stall
progress, and view-change mechanisms allow replicas to safely move to a new
leader without violating safety.

Our recovery protocol applies this analogy directly: each account acts as a
leader, sequencing its own transactions across nonces. Client equivocation
corresponds to leader equivocation in consensus. Recovery consists of
collecting validator attestations about prior votes -- analogous to view-change
messages -- and safely advancing the account's ``view'' (nonce) without
reverting finalized state.

The design is inspired by Simplex-style~\cite{simplex} $\bot$-voting and
Minimmit~\cite{minimmit}, which extends Simplex to achieve one round-trip
finality in the $5f+1$ model by separating notarisation and finalisation
quorum thresholds.
