\chapter{Background and Preliminaries}
\label{chap:background}

\section{Cryptographic Primitives}
\label{sec:crypto-primitives}

\textbf{Hash functions.}
We use a cryptographic hash function $H: \{0,1\}^* \rightarrow \{0,1\}^\lambda$. We assume standard security properties (in particular collision resistance): it is computationally infeasible for any probabilistic polynomial-time (PPT) adversary to find $x \neq y$ such that $H(x) = H(y)$. Hash functions are used to derive compact identifiers (e.g., transaction digests) and to commit to protocol data structures.

\textbf{Digital signatures.}
We assume a digital signature scheme $\Sigma = (\textsf{KeyGen}, \textsf{Sign}, \textsf{Verify})$, where:
\begin{itemize}
    \item $(pk, sk) \leftarrow \textsf{KeyGen}(1^\lambda)$,
    \item $\sigma \leftarrow \textsf{Sign}(sk, m)$,
    \item $\textsf{Verify}(pk, m, \sigma) \in \{0, 1\}$.
\end{itemize}

We assume existential unforgeability under chosen-message attacks (EUF-CMA): for any PPT adversary with access to a signing oracle $\textsf{Sign}(sk, \cdot)$, the probability of outputting a new valid pair $(m^\star, \sigma^\star)$ such that $\textsf{Verify}(pk, m^\star, \sigma^\star) = 1$ and $m^\star$ was never queried to the signing oracle is negligible in $\lambda$. Signatures provide authentication and non-repudiation for transactions and validator votes.

\textbf{Notation.}
We use $\langle v_1, v_2, \ldots \rangle_p$ to denote a tuple $(v_1, v_2, \ldots)$ signed by party $p$.

\section{System Model}
\label{sec:system-model}

\textbf{Parties.}
We consider two types of parties:

\textbf{Validators.}
Validators (called authorities in FastPay~\cite{fastpay}) maintain the protocol state, validate transactions, and produce attestations/votes required for transaction confirmation. In typical proof-of-stake systems, validators are selected based on stake. For the purpose of our construction, we assume a fixed validator set $\mathcal{V}$ of size $n = |\mathcal{V}|$. Each validator $v_i \in \mathcal{V}$ has a public/private key pair $(pk_i, sk_i)$. We assume validators' public keys and network addresses (e.g., IP/port) are globally known to all participants.

\textbf{Clients.}
Clients are the users of the protocol. They create and submit transactions. Each client has a fixed public/private key pair $(pk, sk)$ and is identified by its unique public key.

\textbf{Adversary model.}
We assume a Byzantine adversary controlling up to $f$ validators. We write:
\begin{itemize}
    \item $n$: total number of validators,
    \item $f$: number of Byzantine validators, with $f < n$.
\end{itemize}

Honest parties follow the protocol as specified. Byzantine parties may deviate arbitrarily (including equivocation, selective message dropping, or sending conflicting messages).

We distinguish two client behaviors: \emph{honest clients} follow the protocol, while \emph{Byzantine clients} may deviate arbitrarily. Under relaxed termination (Section~\ref{sec:termination-tradeoff}), Byzantine clients that introduce conflicts are not guaranteed liveness-the protocol may halt progress for that client's state. Safety is preserved unconditionally, but liveness is sacrificed in the presence of conflicts.

We assume static corruption: the adversary chooses which parties to corrupt at the beginning of execution and can coordinate all corrupted parties.

\textbf{Network model and responsiveness.}
We assume authenticated point-to-point communication channels between parties (authentication provided by signatures and/or established secure channels).

We work in the partially synchronous model (Dwork--Lynch--Stockmeyer style~\cite{dls}): there exists a (possibly unknown) time called the \emph{Global Stabilization Time} (GST) after which message delays are bounded. Concretely:
\begin{itemize}
    \item $\delta$: the actual message delay experienced by the network at a given time,
    \item $\Delta$: an unknown upper bound such that after GST, $\delta \leq \Delta$ and all messages between honest parties are delivered within $\Delta$.
\end{itemize}

Before GST, the network may behave asynchronously with unbounded delays. After GST, the network is synchronous with bounded delay $\Delta$. The protocol does not know when GST occurs.

A protocol is \emph{responsive} if its liveness depends only on actual delays $\delta$, not on knowing $\Delta$~\cite{hotstuff}. Our recovery protocol is responsive: confirmation latency scales with actual network delay rather than a worst-case bound.

\section{Transactions, Ledgers, and Consensus}
\label{sec:transactions-ledgers}

\textbf{Transactions.}
We model a transaction as a tuple
\[
tx = (\textsf{sender}, \textsf{recipient}, \textsf{amount}, \textsf{nonce}, \textsf{data}),
\]
signed by the sender. Intuitively:
\begin{itemize}
    \item \textsf{sender} identifies the authorizing account,
    \item \textsf{recipient} identifies the destination account or contract,
    \item \textsf{amount} transfers value,
    \item \textsf{nonce} is a per-sender sequence number used for local ordering,
    \item \textsf{data} encodes optional call data (e.g., smart contract inputs).
\end{itemize}

In account-based blockchains, if \textsf{data} is empty, the transaction is treated as a simple transfer; otherwise, it invokes code at the recipient address. In this thesis we focus on FastPay-style payments, and therefore assume $\textsf{data} = \emptyset$ in the concrete construction (Chapter~\ref{chap:protocol}). Later, we discuss how the recovery intuition extends to other consensusless protocols, including those with single-writer contract-like state.

\textbf{Precompiled contracts.}
In Ethereum and compatible blockchains, \emph{precompiled contracts} (or \emph{precompiles}) are special addresses
that provide native functionality implemented directly in the node software rather than as EVM bytecode. Examples
include cryptographic operations like ECDSA recovery and hash functions. From the client's perspective, interacting
with a precompile looks identical to calling a regular smart contract: the client sends a transaction to the
precompile's address with appropriate data. This design maintains backward compatibility with existing wallets
and tooling, as no changes to the transaction format are required. In Chapter~\ref{chap:protocol}, we use a
precompile-style approach for our recovery mechanism.

\textbf{The ledger abstraction and state machine replication.}
A traditional blockchain maintains a global ledger
\[
L = (tx_1, tx_2, \ldots),
\]
a totally ordered sequence of transactions intended to represent the system's history over time. We write $L \preceq L'$ to denote that $L$ is a prefix of $L'$, and $L \sim L'$ if $L \preceq L'$ or $L' \preceq L$.

At the core of most blockchain protocols is a consensus protocol that continuously takes transactions from a mempool, totally orders them, and outputs an ever-growing ledger. Given a deterministic state transition function $F$ (a ``virtual machine'' or state machine), validators apply state machine replication~\cite{smr}: starting from a common genesis state $S_0$, each validator iteratively computes
\[
S_{t+1} = F(S_t, tx_{t+1}).
\]
If all honest validators execute the same ordered ledger, they compute the same state (and thus the same state root) at each step.

\textbf{SMR safety and liveness.}
A state machine replication protocol must satisfy two properties.

\begin{definition}[Ledger Safety]
A ledger is safe iff for any two honest parties $P_1, P_2$, for all rounds $r_1, r_2$, $L_{P_1}^{r_1} \sim L_{P_2}^{r_2}$ holds.
\end{definition}

\begin{definition}[Ledger Liveness]
A protocol satisfies liveness with parameter $u$ if, when an honest party $P$ submits a transaction $tx$ at round $r$, the transaction must appear in any honest party's view of the ledger $L_{P'}^{r'}$ by round $r'$, where $r' \geq r + u$.
\end{definition}

\section{Consensusless Protocols}
\label{sec:consensusless-protocols}

In this thesis, we use \emph{consensusless protocols} to mean protocols that avoid global consensus and total ordering. The key idea is that many workloads do not require a globally agreed total order to be safely executed.

\textbf{Payments without total order.}
The original motivation for blockchains was Byzantine fault-tolerant payments. However, it has been shown that global payments can be supported without solving consensus: it is sufficient to ensure local ordering for each sender and to restrict state updates so that conflicts are avoided~\cite{consensus-number}. Intuitively, independent transfers (e.g., Alice$\rightarrow$Bob and Charlie$\rightarrow$Dave) do not interact, and reordering them yields the same final state.

More generally, many safe fast-path operations are commutative: executing them in different orders produces the same resulting state. For example, consider two independent deposits to the same account:
\[
+\$5 \text{ and } +\$7 \text{ commute, so their order does not matter.}
\]

The main non-commutative edge case arises from overspending. Subtractions are not commutative in the presence of an underflow constraint (e.g., balances must remain non-negative). Whether a withdrawal is valid depends on the ordering of that account's outgoing payments.

\textbf{Consensus number intuition.}
Payments can avoid consensus because validity checks for spending can be made locally by the spender. An honest client can ensure a new transfer does not underflow given its confirmed deposits and outgoing payments. Other parties can increase a client's balance but cannot decrease it. This asymmetry is why cryptocurrency-like objects have consensus number 1~\cite{consensus-number}.

\textbf{Why consensusless protocols are fast.}
Avoiding consensus eliminates multiple rounds of validator-to-validator coordination. As a concrete data point, FastPay~\cite{fastpay} reports intra-continental confirmation latency below 100ms and throughput above 80,000 transactions per second with 20 authorities in controlled experiments.

For comparison, consensus protocols-even highly optimized modern ones-require multiple message rounds to commit. For example, HotStuff-style protocols~\cite{hotstuff} commit through multiple phases (often described as three round trips in the baseline design). Recent DAG-based consensus protocols reduce latency and can reach very high throughput, but they still solve a global ordering problem and therefore incur additional coordination; Mysticeti-C~\cite{mysticeti} reports WAN commit latency around 0.5s while sustaining over 200k TPS.

Consensusless protocols also enable horizontal scalability because execution can be sharded by object/account: disjoint state can be processed in parallel across machines, a property emphasized in FastPay's design.

\section{The Termination Tradeoff}
\label{sec:termination-tradeoff}
\za{is this section necessary? do you use these definitions later? the point of this section is to expose the things you need and will prove later. One set of defintions, either SMR or consensus is enough, unless you use the consensus defintions to prove SMR.}
\sa{I have moved most of the other stuff from this section elsewhere (expressiveness classes to related work, client types to system model, permanent locking to FastPay chapter). I find this relaxation of termination condition provides good theoretical understanding. Should we move it to an appendix or somewhere else?}
To better understand the tradeoffs made by consensusless protocols, it is helpful to start from the classical definition of single-shot consensus.

\textbf{Single-shot consensus.}
In a single-shot consensus instance, parties must decide on a single value (e.g., one proposal among potentially conflicting candidates).

\begin{definition}[Single-shot Consensus]
A protocol solves Byzantine consensus if it satisfies:
\begin{itemize}
    \item \textbf{Agreement.} No two honest parties decide different values.
    \item \textbf{Validity.} If all honest parties start with the same value $v$, then $v$ is the only value that can be decided by honest parties.
    \item \textbf{Termination.} Every honest party eventually decides some value.
\end{itemize}
\end{definition}

The key point is that termination is unconditional: progress must occur even under conflicts. This coordination requirement is a primary contributor to the latency and throughput costs of consensus-backed blockchains.

\textbf{Relaxed termination.}
Consensusless protocols improve performance by weakening termination: instead of requiring progress under arbitrary conflicts, they require progress only when there is no conflict~\cite{abc}.

\begin{definition}[Consensus with Relaxed Termination~\cite{abc}]
A protocol satisfies relaxed consensus if it provides:
\begin{itemize}
    \item \textbf{Agreement.} No two honest parties decide different values.
    \item \textbf{Validity.} If all honest parties start with the same value $v$, then $v$ is the only value that can be decided by honest parties.
    \item \textbf{No-conflict termination.} If every honest party observes non-conflicting transactions (informally, there exists a unique ``consistent'' value to decide), then every honest party eventually decides.
\end{itemize}
\end{definition}

This relaxation is the core semantic tradeoff: the protocol remains safe under conflicts, but may stop making progress on conflicting state.

\section{Healing Clients and Recovery}
\label{sec:healing-clients}

The lack of liveness under conflicts is often described as a limitation affecting only malicious clients. In practice, however, conflict behavior can occur naturally due to benign faults and common wallet behavior, making it a significant obstacle to deploying consensusless protocols in production.

First, it is common in existing blockchain ecosystems for wallets to intentionally reuse the same nonce to replace or cancel a pending transaction-for example, by reissuing an otherwise empty transfer with a higher fee so that the new transaction supersedes the old one in the mempool. This technique is a routine part of user experience in account-based systems. In a consensusless protocol that relies on local ordering, the same behavior becomes equivocation: different validators may observe different transactions for the same nonce, which can lead to a permanent lock under existing designs.

Second, many widely deployed wallets are effectively stateless. A typical workflow is: wake up, query a full node for the latest nonce, construct a transaction, sign, and send-without persisting additional state beyond the private key. In a synchronous blockchain with a globally ordered ledger, this is often sufficient: the chain defines the canonical nonce progression. In consensusless protocols, this becomes problematic. If a wallet crashes after sending a transaction but before persisting the used nonce (or before learning which validators observed it), the wallet may later resend with the same nonce, unintentionally equivocating. Preventing this would require wallets to implement a non-equivocation gadget-e.g., durable local storage and crash-recovery logic that ensures a nonce is never reused-which begins to resemble the operational complexity of validator setups. This breaks composability with existing wallet infrastructure and significantly raises the bar for adoption.

This thesis addresses precisely this practical gap: enabling robust progress for clients that may equivocate due to benign faults, without requiring wallets to become stateful or to implement sophisticated non-equivocation mechanisms.

We formalize this deployment-relevant client behavior using the notion of a \emph{healing client}.

\begin{definition}[Healing client]
A client is \emph{healing} if it may deviate arbitrarily for some period of time (e.g., due to crashes, bugs, or lost local state), but after some time $t_h$ it follows the protocol correctly.
\end{definition}

Our recovery protocol (Chapter~\ref{chap:protocol}) provides liveness for healing clients: even if a client previously equivocated and became locked, once it ``heals'' it can safely recover and continue making progress. Importantly, the goal is not to restore unconditional termination for permanently Byzantine clients; a client that continues to equivocate indefinitely is not guaranteed to recover. Instead, we aim for a practical guarantee: benign faults should not permanently brick an account, and recovery should be possible without fallback consensus or new wallet-side infrastructure.
