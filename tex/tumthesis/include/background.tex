\chapter{Background and Preliminaries}
\label{chap:background}

\section{Cryptographic Primitives}
\label{sec:crypto-primitives}

\textbf{Hash functions.}
We use a cryptographic hash function $H: \{0,1\}^* \rightarrow \{0,1\}^\lambda$. We assume standard security properties (in particular collision resistance): it is computationally infeasible for any probabilistic polynomial-time (PPT) adversary to find $x \neq y$ such that $H(x) = H(y)$. Hash functions are used to derive compact identifiers (e.g., transaction digests) and to commit to protocol data structures.

\textbf{Digital signatures.}
We assume a digital signature scheme $\Sigma = (\textsf{KeyGen}, \textsf{Sign}, \textsf{Verify})$, where:
\begin{itemize}
    \item $(pk, sk) \leftarrow \textsf{KeyGen}(1^\lambda)$,
    \item $\sigma \leftarrow \textsf{Sign}(sk, m)$,
    \item $\textsf{Verify}(pk, m, \sigma) \in \{0, 1\}$.
\end{itemize}

We assume existential unforgeability under chosen-message attacks (EUF-CMA): for any PPT adversary with access to a signing oracle $\textsf{Sign}(sk, \cdot)$, the probability of outputting a new valid pair $(m^\star, \sigma^\star)$ such that $\textsf{Verify}(pk, m^\star, \sigma^\star) = 1$ and $m^\star$ was never queried to the signing oracle is negligible in $\lambda$. Signatures provide authentication and non-repudiation for transactions and validator votes.

\textbf{Notation.}
We use $\langle v_1, v_2, \ldots \rangle_p$ to denote a tuple $(v_1, v_2, \ldots)$ signed by party $p$.

\section{System Model}
\label{sec:system-model}

\textbf{Parties.}
We consider two types of parties:

\textbf{Validators.}
Validators (called authorities in FastPay~\cite{fastpay}) maintain the protocol state, validate transactions, and produce attestations/votes required for transaction confirmation. In typical proof-of-stake systems, validators are selected based on stake. For the purpose of our construction, we assume a fixed validator set $\mathcal{V}$ of size $n = |\mathcal{V}|$. Each validator $v_i \in \mathcal{V}$ has a public/private key pair $(pk_i, sk_i)$. We assume validators' public keys and network addresses (e.g., IP/port) are globally known to all participants.

\textbf{Clients.}
Clients are the users of the protocol. They create and submit transactions. Each client has a fixed public/private key pair $(pk, sk)$ and is identified by its unique public key.

\textbf{Adversary model.}
We assume a Byzantine adversary controlling up to $f$ validators. We write:
\begin{itemize}
    \item $n$: total number of validators,
    \item $f$: number of Byzantine validators, with $f < n$.
\end{itemize}

Honest parties follow the protocol as specified. Byzantine parties may deviate arbitrarily (including equivocation, selective message dropping, or sending conflicting messages).

We assume static corruption: the adversary chooses which parties to corrupt at the beginning of execution and can coordinate all corrupted parties.

\textbf{Network model and responsiveness.}
We assume authenticated point-to-point communication channels between parties (authentication provided by signatures and/or established secure channels).

We work in the partially synchronous model (Dwork--Lynch--Stockmeyer style~\cite{dls}): there exists a (possibly unknown) time after which message delays are bounded, but the bound is not known to the protocol. Concretely, we use:
\begin{itemize}
    \item $\delta$: the actual message delay experienced by the network at a given time,
    \item $\Delta$: an unknown upper bound such that eventually $\delta \leq \Delta$, and all messages between honest parties are delivered.
\end{itemize}

A protocol is \emph{responsive} if its liveness depends only on actual delays $\delta$, not on knowing $\Delta$~\cite{hotstuff}. Our recovery protocol is responsive.

\section{Transactions, Ledgers, and Consensus}
\label{sec:transactions-ledgers}

\textbf{Transactions.}
We model a transaction as a tuple
\[
tx = (\textsf{sender}, \textsf{recipient}, \textsf{amount}, \textsf{nonce}, \textsf{data}),
\]
signed by the sender. Intuitively:
\begin{itemize}
    \item \textsf{sender} identifies the authorizing account,
    \item \textsf{recipient} identifies the destination account or contract,
    \item \textsf{amount} transfers value,
    \item \textsf{nonce} is a per-sender sequence number used for local ordering,
    \item \textsf{data} encodes optional call data (e.g., smart contract inputs).
\end{itemize}

In account-based blockchains, if \textsf{data} is empty, the transaction is treated as a simple transfer; otherwise, it invokes code at the recipient address. In this thesis we focus on FastPay-style payments, and therefore assume $\textsf{data} = \emptyset$ in the concrete construction (Chapter~\ref{chap:protocol}). Later, we discuss how the recovery intuition extends to other asynchronous protocols, including those with single-writer contract-like state.

\textbf{The ledger abstraction and state machine replication.}
A traditional blockchain maintains a global ledger
\[
L = (tx_1, tx_2, \ldots),
\]
a totally ordered sequence of transactions intended to represent the system's history over time.

At the core of most blockchain protocols is a consensus protocol that continuously takes transactions from a mempool, totally orders them, and outputs an ever-growing ledger. Given a deterministic state transition function $F$ (a ``virtual machine'' or state machine), validators apply state machine replication~\cite{smr}: starting from a common genesis state $S_0$, each validator iteratively computes
\[
S_{t+1} = F(S_t, tx_{t+1}).
\]
If all honest validators execute the same ordered ledger, they compute the same state (and thus the same state root) at each step.

\section{Asynchronous Protocols}
\label{sec:async-protocols}

In this thesis, we use \emph{asynchronous protocols} to mean protocols that avoid global consensus and total ordering, not necessarily protocols that assume a fully asynchronous network. The key idea is that many workloads do not require a globally agreed total order to be safely executed.

\textbf{Payments without total order.}
The original motivation for blockchains was Byzantine fault-tolerant payments. However, it has been shown that global payments can be supported without solving consensus: it is sufficient to ensure local ordering for each sender and to restrict state updates so that conflicts are avoided~\cite{consensus-number}. Intuitively, independent transfers (e.g., Alice$\rightarrow$Bob and Charlie$\rightarrow$Dave) do not interact, and reordering them yields the same final state.

More generally, many safe fast-path operations are commutative: executing them in different orders produces the same resulting state. For example, consider two independent deposits to the same account:
\[
+\$5 \text{ and } +\$7 \text{ commute, so their order does not matter.}
\]

The main non-commutative edge case arises from overspending. Subtractions are not commutative in the presence of an underflow constraint (e.g., balances must remain non-negative). Whether a withdrawal is valid depends on the ordering of that account's outgoing payments.

\textbf{Consensus number intuition.}
Payments can avoid consensus because validity checks for spending can be made locally by the spender. An honest client can ensure a new transfer does not underflow given its confirmed deposits and outgoing payments. Other parties can increase a client's balance but cannot decrease it. This asymmetry is why cryptocurrency-like objects have consensus number 1~\cite{consensus-number}.

\textbf{Why async protocols are fast.}
Avoiding consensus eliminates multiple rounds of validator-to-validator coordination. As a concrete data point, FastPay~\cite{fastpay} reports intra-continental confirmation latency below 100ms and throughput above 80,000 transactions per second with 20 authorities in controlled experiments.

For comparison, consensus protocols-even highly optimized modern ones-require multiple message rounds to commit. For example, HotStuff-style protocols~\cite{hotstuff} commit through multiple phases (often described as three round trips in the baseline design). Recent DAG-based consensus protocols reduce latency and can reach very high throughput, but they still solve a global ordering problem and therefore incur additional coordination; Mysticeti-C~\cite{mysticeti} reports WAN commit latency around 0.5s while sustaining over 200k TPS.

Async protocols also enable horizontal scalability because execution can be sharded by object/account: disjoint state can be processed in parallel across machines, a property emphasized in FastPay's design.

\section{FastPay Protocol Overview}
\label{sec:fastpay-overview}

We now describe a simplified version of the FastPay protocol~\cite{fastpay} that forms the basis for our recovery construction. FastPay is a Byzantine fault-tolerant payment system that achieves confirmation in a single round trip without requiring consensus among validators. The protocol operates with $n \geq 3f + 1$ validators, where $f$ is the maximum number of Byzantine validators.

\textbf{Certificates and quorums.}
A $q$-certificate for account $a$ at nonce $k$ is a set of at least $q$ signed votes from unique validators in $\mathcal{V}$ on the same $(a, k)$ pair, but possibly on different messages. A $q$-quorum is a $q$-certificate where all votes are on the same message $m$.

\textbf{Validator protocol.}
Algorithm~\ref{alg:validator} shows the simplified validator logic.

\begin{algorithm}[h]
\caption{Honest Validator}\label{alg:validator}
\begin{algorithmic}[1]
\State \textbf{global} $\mathcal{V}$: validator set
\State \textbf{state} $\mathsf{account}[\cdot]$: mapping from client public key to $(\mathsf{balance}, \mathsf{nonce}, \mathsf{pending})$
\Statex
\Procedure{OnTransaction}{$tx, \sigma$}
    \State \textbf{verify} $\sigma$ is a valid signature from $tx.\mathsf{sender}$ on $tx$
    \State \textbf{require} $\mathsf{account}[tx.\mathsf{sender}].\mathsf{pending} = \mathsf{false}$
    \State \textbf{require} $\mathsf{account}[tx.\mathsf{sender}].\mathsf{nonce} = tx.\mathsf{nonce}$
    \State \textbf{require} $\mathsf{account}[tx.\mathsf{sender}].\mathsf{balance} \geq tx.\mathsf{amount}$
    \State $\mathsf{account}[tx.\mathsf{sender}].\mathsf{pending} \gets \mathsf{true}$
    \State \Return $\langle \mathsf{vote}, tx \rangle_v$
\EndProcedure
\Statex
\Procedure{OnCertificate}{$tx, C$}
    \State \textbf{require} $C$ is a valid $(n-f)$-quorum on $tx$
    \State \textbf{require} $\mathsf{account}[tx.\mathsf{sender}].\mathsf{nonce} = tx.\mathsf{nonce}$
    \State $\mathsf{account}[tx.\mathsf{sender}].\mathsf{pending} \gets \mathsf{false}$
    \State $\mathsf{account}[tx.\mathsf{sender}].\mathsf{nonce} \gets \mathsf{nonce} + 1$
    \State $\mathsf{account}[tx.\mathsf{sender}].\mathsf{balance} \mathrel{-}= tx.\mathsf{amount}$
    \State $\mathsf{account}[tx.\mathsf{recipient}].\mathsf{balance} \mathrel{+}= tx.\mathsf{amount}$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Client protocol.}
Algorithm~\ref{alg:client} shows the simplified client logic.

\begin{algorithm}[h]
\caption{Honest Client}\label{alg:client}
\begin{algorithmic}[1]
\State \textbf{global} $\mathcal{V}$: validator set
\State \textbf{state} $\mathsf{nonce}$: local transaction sequence number
\Statex
\Procedure{SendTransaction}{$\mathsf{to}, \mathsf{amount}$}
    \State $tx \gets (\mathsf{self}, \mathsf{to}, \mathsf{amount}, \mathsf{nonce}, \bot)$
    \State $\mathsf{nonce} \gets \mathsf{nonce} + 1$
    \State broadcast $(tx, \langle tx \rangle_{\mathsf{self}})$ to $\mathcal{V}$
    \State wait for $n - f$ valid votes to construct certificate $C$
    \State broadcast $(tx, C)$ to $\mathcal{V}$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\textbf{Transaction flow.}
A transaction proceeds in three phases:
\begin{enumerate}
    \item \textbf{Validation.} The client constructs a transaction, signs it, and broadcasts it to all validators. Each validator checks that (i) the signature is valid, (ii) no transaction is currently pending for this account, (iii) the nonce matches the expected value, and (iv) the balance is sufficient. If all checks pass, the validator sets the pending flag and returns a signed vote.
    \item \textbf{Confirmation.} Once the client collects $n - f$ votes, the transaction is considered finalized, even though the state has not yet been updated. This is the confirmation latency of the protocol: $2\delta$ or one network round trip (client to validators and back).
    \item \textbf{Execution.} The client assembles the votes into a certificate and broadcasts it to all validators. Upon receiving a valid certificate, validators execute the transaction: they clear the pending flag, increment the nonce, and update balances.
\end{enumerate}

\textbf{Safety.}
Safety relies on the fact that each validator votes for at most one transaction per nonce (enforced by the pending flag and nonce check). Since $n \geq 3f + 1$, any two $(n-f)$-quorums must intersect in at least $(n - f) + (n - f) - n = n - 2f \geq f + 1$ validators. With at most $f$ Byzantine validators, any two quorums share at least one honest validator. An honest validator only votes once per nonce, so two conflicting certificates for the same nonce cannot both exist. This ensures that conflicting transactions cannot both be finalized.

\textbf{Liveness.}
Liveness holds for honest clients that do not equivocate. If a client sends a single transaction for each nonce, it will eventually collect $n - f$ votes (since at least $n - f$ validators are honest and will respond). The client can then form a certificate and finalize the transaction. Critically, if a client sends conflicting transactions for the same nonce, different validators may vote for different transactions, and neither may reach $n - f$ votes - the account becomes locked.

\section{Expressiveness and Client Types}
\label{sec:expressiveness}

To better understand the tradeoffs made by asynchronous protocols, it is helpful to start from the classical definition of single-shot consensus.

\textbf{Single-shot consensus.}
In a single-shot consensus instance, parties must decide on a single value (e.g., one proposal among potentially conflicting candidates).

\begin{definition}[Single-shot Consensus]
A protocol solves Byzantine consensus if it satisfies:
\begin{itemize}
    \item \textbf{Agreement.} No two honest parties decide different values.
    \item \textbf{Validity.} If all honest parties start with the same value $v$, then $v$ is the only value that can be decided by honest parties.
    \item \textbf{Termination.} Every honest party eventually decides some value.
\end{itemize}
\end{definition}

The key point is that termination is unconditional: progress must occur even under conflicts. This coordination requirement is a primary contributor to the latency and throughput costs of consensus-backed blockchains.

\textbf{Relaxed termination.}
Asynchronous protocols improve performance by weakening termination: instead of requiring progress under arbitrary conflicts, they require progress only when there is no conflict~\cite{abc}.

\begin{definition}[Consensus with Relaxed Termination~\cite{abc}]
A protocol satisfies relaxed consensus if it provides:
\begin{itemize}
    \item \textbf{Agreement.} No two honest parties decide different values.
    \item \textbf{Validity.} If all honest parties start with the same value $v$, then $v$ is the only value that can be decided by honest parties.
    \item \textbf{No-conflict termination.} If every honest party observes non-conflicting transactions (informally, there exists a unique ``consistent'' value to decide), then every honest party eventually decides.
\end{itemize}
\end{definition}

This relaxation is the core semantic tradeoff: the protocol remains safe under conflicts, but may stop making progress on conflicting state. This naturally leads to an expressiveness boundary - which kinds of replicated state can be updated without creating conflicts? We organize state updates into three broad classes:
\begin{enumerate}
    \item \textbf{Commutative multi-writer state (CRDT-like).} If all updates commute, the system can safely apply them in any order and still converge. A simple example is a balance that supports deposits only: two deposits of $+5$ and $+7$ commute, so regardless of order, the final balance increases by $12$. This is closely related to Conflict-Free Replicated Data Types (CRDTs)~\cite{crdt}, where concurrent updates can be merged deterministically without coordination.

    \item \textbf{Non-commutative single-writer state.} Some updates do not commute, but conflicts can be avoided if each object has a single writer that imposes a local order on its own updates. A canonical example is a balance that supports withdrawals: the success of a withdrawal depends on the order of previous withdrawals due to the non-negativity constraint. With a single writer, conflicts can be prevented by ensuring the writer never issues competing updates for the same sequence position. Under relaxed termination, liveness is guaranteed only as long as the writer behaves correctly.

    \item \textbf{Non-commutative multi-writer state.} If multiple independent writers can issue non-commutative updates to the same object, conflicts can arise even when all writers are honest. For example, if two parties can concurrently withdraw from the same balance-constrained state, the decision of which withdrawal succeeds depends on ordering and cannot be resolved by local reasoning. This class requires stronger synchronization and is precisely where consensus-like power reappears~\cite{consensus-number}.
\end{enumerate}

\textbf{Honest vs Byzantine clients.}
We distinguish two client behaviors: \emph{honest clients} follow the protocol, while \emph{Byzantine clients} may deviate arbitrarily. Under relaxed termination, Byzantine clients that introduce conflicts are not guaranteed liveness - the protocol may halt progress for that client's state. This is a fundamental limitation: safety is preserved unconditionally, but liveness is sacrificed in the presence of conflicts.

\textbf{Equivocation and permanent locking.}
To see concretely how equivocation leads to permanent loss of liveness in the FastPay protocol described above, consider a client that broadcasts two conflicting transactions $tx$ and $tx'$ with the same nonce. With $n = 3f + 1$ validators, suppose $f + 1$ honest validators vote for $tx$ and $f$ honest validators vote for $tx'$ (the remaining $f$ are Byzantine and may vote arbitrarily). The client can collect at most $(f + 1) + f = 2f + 1$ votes for $tx$ and at most $f + (f) + f = 3f$ votes for $tx'$. Since a certificate requires $n - f = 2f + 1$ votes, neither transaction can reach a quorum if the Byzantine validators split their votes or abstain. The account is now locked: the pending flag is set at all honest validators, no certificate can be formed, and no future transaction with a higher nonce can proceed.

\section{Healing Clients and Recovery}
\label{sec:healing-clients}

The lack of liveness under conflicts is often described as a limitation affecting only malicious clients. In practice, however, conflict behavior can occur naturally due to benign faults and common wallet behavior, making it a significant obstacle to deploying asynchronous protocols in production.

First, it is common in existing blockchain ecosystems for wallets to intentionally reuse the same nonce to replace or cancel a pending transaction-for example, by reissuing an otherwise empty transfer with a higher fee so that the new transaction supersedes the old one in the mempool. This technique is a routine part of user experience in account-based systems. In an asynchronous protocol that relies on local ordering, the same behavior becomes equivocation: different validators may observe different transactions for the same nonce, which can lead to a permanent lock under existing designs.

Second, many widely deployed wallets are effectively stateless. A typical workflow is: wake up, query a full node for the latest nonce, construct a transaction, sign, and send-without persisting additional state beyond the private key. In a synchronous blockchain with a globally ordered ledger, this is often sufficient: the chain defines the canonical nonce progression. In asynchronous protocols, this becomes problematic. If a wallet crashes after sending a transaction but before persisting the used nonce (or before learning which validators observed it), the wallet may later resend with the same nonce, unintentionally equivocating. Preventing this would require wallets to implement a non-equivocation gadget-e.g., durable local storage and crash-recovery logic that ensures a nonce is never reused-which begins to resemble the operational complexity of validator setups. This breaks composability with existing wallet infrastructure and significantly raises the bar for adoption.

This thesis addresses precisely this practical gap: enabling robust progress for clients that may equivocate due to benign faults, without requiring wallets to become stateful or to implement sophisticated non-equivocation mechanisms.

We formalize this deployment-relevant client behavior using the notion of a \emph{healing client}.

\begin{definition}[Healing client]
A client is \emph{healing} if it may deviate arbitrarily for some period of time (e.g., due to crashes, bugs, or lost local state), but after some time $t_h$ it follows the protocol correctly.
\end{definition}

Our recovery protocol is designed to provide liveness for healing clients: even if a client previously equivocated and became locked, once it ``heals'' it can safely recover and continue making progress in the asynchronous path. Importantly, the goal is not to restore unconditional termination for permanently Byzantine clients; a client that continues to equivocate indefinitely is not guaranteed to recover and may remain locked. Instead, we aim for a practical guarantee aligned with real deployments: benign faults should not permanently brick an account, and recovery should be possible without introducing fallback consensus or requiring new wallet-side infrastructure.
